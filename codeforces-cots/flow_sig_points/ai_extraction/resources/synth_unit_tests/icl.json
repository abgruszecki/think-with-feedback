[
{"idx": 0, "offset": 1042, "inputs": {"simulations": "<simulation type=\"code\">\nTesting the examples:\n\nFor input 5: bin(5)[2:] \u2192 '101', correct.\n\nFor input 13: bin(13)[2:] \u2192 '1101', correct.\n</simulation>", "code": "n = int(input())\nprint(bin(n)[2:])\n", "problem_statement": "You are given a positive integer n. Output its binary notation.", "input_format": "The only line of input data contains an integer n (1 \u2264 n \u2264 106).", "output_format": "Output the binary notation of n (without any leading zeros).", "examples": [{"input": "5", "output": "101"}, {"input": "13", "output": "1101"}], "problem_notes": "In the first example 5 = 1 * 22 + 0 * 21 + 1 * 20."}, "response": "```python\nimport io\n\ndef to_binary(input_stream, output_stream):\n    n = int(input_stream.readline().strip())\n    print(bin(n)[2:], file=output_stream)\n\ndef test_to_binary():\n    test_cases = [\n        (5, \"101\"),\n        (13, \"1101\")\n    ]\n    \n    for i, (input_val, expected_output) in enumerate(test_cases, 1):\n        input_stream = io.StringIO(str(input_val))\n        output_stream = io.StringIO()\n        to_binary(input_stream, output_stream)\n        actual_output = output_stream.getvalue().rstrip()\n        if actual_output != expected_output:\n            print(f\"Test case {i} failed! input({input_val!r}) => expected({expected_output!r}), got({actual_output!r})\")\n            exit(1)\n    \n    print(\"All test cases passed.\")\n\nif __name__ == \"__main__\":\n    test_to_binary()\n```"},
{"idx": 1, "offset": 2400, "inputs": {"simulations": "<simulation type=\"code\">\nYes, that should work. Let me check the examples.\n\nFirst example input: \"VK-Cup-2012!\". The list comprehension will take all characters except '2','0','1','2'. So the result is \"VK-Cup-!\".\n\nSecond example input: \"Go,Codeforces!\" has no digits, so the output is the same as input.\n\nAnother test case: input is \"1234\", output is empty string. Which is handled correctly.\n</simulation>", "code": "s = input().strip()\nresult = ''.join([c for c in s if not c.isdigit()])\nprint(result)\n", "problem_statement": "You are given a string. Remove all digits from it. When a character is removed from a string, all characters to the right of it are shifted one position to the left.", "input_format": "The only line of input contains a string between 1 and 100 characters long. Each character of the string has ASCII-code between 33 (exclamation mark) and 126 (tilde), inclusive.", "output_format": "Output the given string with all digits removed from it. If the original string had only digits, output an empty string.", "examples": [{"input": "VK-Cup-2012!", "output": "VK-Cup-!"}, {"input": "Go,Codeforces!", "output": "Go,Codeforces!"}], "problem_notes": null}, "response": "```python\nimport io\n\ndef remove_digits(input_stream, output_stream):\n    s = input_stream.readline().strip()\n    print(''.join([c for c in s if not c.isdigit()]), file=output_stream)\n\ndef test_remove_digits():\n    test_cases = [\n        (\"VK-Cup-2012!\", \"VK-Cup-!\"),\n        (\"Go,Codeforces!\", \"Go,Codeforces!\"),\n        (\"1234\", \"\"),\n    ]\n\n    for i, (input_str, expected_output) in enumerate(test_cases, 1):\n        input_stream = io.StringIO(input_str)\n        output_stream = io.StringIO()\n        remove_digits(input_stream, output_stream)\n        result = output_stream.getvalue().rstrip()\n        if result != expected_output:\n            print(f\"Test case {i} failed: expected {expected_output!r}, got {result!r}\")\n            exit(1)\n\n    print(\"All test cases passed.\")\n\nif __name__ == \"__main__\":\n    test_remove_digits()\n```"},
{"idx": 4, "offset": 3874, "inputs": {"simulations": "<simulation type=\"code\">\nWait, but let's test this with the examples. For example, input 2 and 3, sum is 5. That works. For the second example, 1390 + 2011 = 3401. Correct. Third example 12345 + 54321 = 66666. So this approach works.\n</simulation>", "code": "print(int(input()) + int(input()))\n", "problem_statement": "Bijan is new to programming. He learned recently that programmers do not code every bit of their apps from scratch.\n\nFor example they never write a code to sum two integers, because their languages have the ability to do the sum. But can they use it? Can an experienced coder who has attended more than 100 contests, sum two integers?\n\nBijan is not sure about this. What's your opinion?", "input_format": "You are given two integers a and b, one per line (1 \u2264 a, b < 10500). These numbers will not have any leading zeros.", "output_format": "Write sum of the two integers. Do not put any leading zeros.", "examples": [{"input": "2\n3", "output": "5"}, {"input": "1390\n2011", "output": "3401"}, {"input": "12345\n54321", "output": "66666"}], "problem_notes": null}, "response": "```python\nimport io\n\ndef sum_two_integers(input_stream, output_stream):\n    def input():\n        return input_stream.readline().rstrip('\\n')\n    print(int(input()) + int(input()), file=output_stream)\n\ndef test():\n    test_cases = [\n        (\"2\\n3\", \"5\"),\n        (\"1390\\n2011\", \"3401\"),\n        (\"12345\\n54321\", \"66666\")\n    ]\n    \n    for i, (input_data, expected_output) in enumerate(test_cases, 1):\n        # Simulate input and capture output\n        input_stream = io.StringIO(input_data)\n        output_stream = io.StringIO()\n        \n        # Run the function\n        sum_two_integers(input_stream, output_stream)\n        result = output_stream.getvalue().rstrip()\n        \n        # Check if the output matches the expected output\n        if result != expected_output:\n            print(f\"Test case {i} failed!\\nExpected:\\n{expected_output}\\nGot:\\n{result}\")\n            exit(1)\n\nif __name__ == \"__main__\":\n    test()\n```"}
]
