<think>
Okay, let's tackle this problem step by step. So, the task is to find the sum of the k smallest zcy numbers and then compute that sum modulo p. A zcy number is a palindrome with an even number of digits. Hmm, right. So first, I need to generate the k smallest such numbers and sum them up.

Wait, what's a zcy number exactly? Oh right, even-length palindrome with no leading zeros. So examples like 11, 22, 33, etc., and then 1221, 1331, etc. So the first few zcy numbers are 11, 22, ..., 99, then 1001, 1111, 1221, and so on. Wait, no. Wait, 1001 is a palindrome of even length. But how do they generate in order?

Wait, the problem says "k smallest zcy numbers". So the order is from smallest to largest. So the first zcy number is 11, then 22, up to 99. Then comes 1111, 1221, 1331, ..., 9999, then 100001, 101101, etc. Wait, no. Wait, maybe there's a pattern in how these numbers can be generated.

Hmm, how can I generate all even-length palindromes in order? Oh, maybe each even-length palindrome can be formed by mirroring a number. For example, 11 is formed by taking 1, mirroring it. Similarly, 22 is 2 mirrored. Then for two-digit palindromes, the numbers are 11 to 99. Then for four digits, the first part is 10 to 99, mirrored. So 1001 is 10 mirrored, 1111 is 11 mirrored, etc. So the even-length palindromes can be generated by taking a number, converting it to a string, appending its reverse, and then converting back to integer.

Yes! So for even-length palindromes, they can be generated by taking a number n, creating a string s = str(n) + str(n)[::-1], then converting s to integer. For example, n=1 gives '11', n=12 gives '1221', etc. So each even-length palindrome is uniquely determined by the first half of its digits. And the first half can be any positive integer, and when you mirror it, you get a palindrome of even length.

So the approach here is to generate these numbers by taking n starting from 1 upwards, generating the palindrome by mirroring, and collecting the first k such numbers. Then sum them modulo p.

So for example, the first zcy number is 11 (from n=1), second is 22 (n=2), ..., 9th is 99 (n=9), then n=10 gives 1001, n=11 gives 1111, etc. This way, generating the numbers in order. Because as n increases, the generated palindrome increases as well. So this approach would generate the numbers in the correct order.

So the algorithm steps would be:

1. Generate the first k even-length palindromes by taking numbers n from 1 upwards, mirror them to form the palindrome, collect until we have k numbers.

2. Sum all these numbers and take modulo p.

So the key is to generate these palindromes efficiently. Let's see how this can be done.

For each n starting at 1, the palindrome is formed by concatenating n with its reverse. So for example, n=123 becomes 123321. But wait, that's a 6-digit number. So the length is even, as required.

So the sequence of palindromes generated this way is indeed the ordered list of even-length palindromes. Let's check the first example:

Sample input 2 and p=100. The two smallest zcy numbers are 11 (sum 11+22=33 mod 100 is 33). Which matches the sample.

Another example: in the second sample, the first five numbers are 11,22,33,44,55. Sum is 11+22+33+44+55=165. 165 mod 30 is 15, which matches.

So the approach is correct.

Now, the problem is to generate the first k such numbers, sum them, and mod p. The constraints are k up to 1e5, which is manageable. Because for k=1e5, the numbers would be n from 1 to 1e5. For each, generate the palindrome and add to sum.

Wait, wait. Wait, for n=1, the palindrome is 11. For n=10, it's 1001, which is the 10th number. Wait, but wait, the order here is that the numbers are generated in the order of their first half. So for example, n=1 is 11, n=2 is 22, ..., n=9 is 99. Then n=10 is 1001 (which is 10 followed by 01 reversed? Wait, wait. Wait, n=10 as a string is '10'. Reversed is '01'. So concatenated as '10' + '01' = '1001', which is 1001, yes. So this is larger than 99. Then n=11 is 1111, which is 1111, which is larger than 1001. So the sequence is 11,22,...,99,1001,1111,1221,..., etc.

So this method generates the palindromes in the correct order. So the algorithm would be:

sum = 0

for i in 1..k:

    generate the i-th even-length palindrome by mirroring i's digits

    add to sum

then sum mod p.

So for each i from 1 to k, create a string s = str(i) + str(i)[::-1], then convert to integer, add to sum.

But for k up to 1e5, this would require O(k) iterations, each with O(d) operations where d is the number of digits of i. But for i up to 1e5, the number of digits is up to 5. So per iteration, even converting to string and back is manageable. Let's calculate:

For k=1e5, each iteration is O(1) since the string operations are per digit, but with fixed digits (since i is up to 1e5, which is 5 digits). So total time would be O(k) time, which for 1e5 is acceptable even in Python, given the time limit (2 seconds). Because 1e5 operations are about 1e5 steps, which is manageable.

So the plan is to generate each of the first k numbers in this way, sum them, and output the sum mod p.

So the code would be something like:

Testing against sample input 1.

```python
def main(input_stream, output_stream):
    k, p = map(int, input_stream.readline().rstrip("\n").split())

    sum_total = 0

    for i in range(1, k+1):

        s = str(i) + str(i)[::-1]

        num = int(s)

        sum_total += num

    print(sum_total % p, file=output_stream)



def test():
    import io

    TEST_CASES = [
        {
            "input": \
"""\
5 30
""",
            "output": \
"""\
15
""",
        }, 
    ]

    for i, test_case in enumerate(TEST_CASES):
        in_stream = io.StringIO(test_case["input"])
        expected_output = test_case["output"].rstrip()

        out_stream = io.StringIO()
        main(in_stream, out_stream)
        real_output = out_stream.getvalue().rstrip()

        assert real_output == expected_output, \
            f'Test case {i} failed.\nExpected: {expected_output!r}\nGot: {real_output!r}'

    print('Tests passed ðŸ˜Ž')


if __name__ == '__main__':
    test()


```

<RUN_SNIPPET>
```output
Tests passed ðŸ˜Ž

```

Second sample: k=5, p=30. Sum is 11+22+33+44+55=165. 165 mod 30 is 165 - 5*30=165-150=15. Correct.

Yes, this seems right.

Now, the question is, can this code handle k=1e5 in Python within the time constraints?

In Python, looping 1e5 times and doing string operations for each iteration. Let's think: for each i, converting to string twice (once for the original, once for reversed). Reversed can be done by slicing [::-1]. Then concatenating, then converting to int.

But converting to int each time may be a bit slow. Wait, but even for i up to 1e5, the generated number is up to 1e5 concatenated with its reverse. For example, i=1e5 (100000), reversed is 000001, but when concatenated, it's '10000000001', which is a 11-digit number. But converting that to int takes O(1) time. Wait, but for k=1e5, each iteration is manageable.

But in Python, loops can be slow. Let's see: for 1e5 iterations, each iteration involving a few string operations and an integer conversion. Let's estimate.

Each iteration:

- Convert i to string: O(1) per digit. For i up to 1e5, which is up to 6 digits (since 1e5 is 100000, which is 6 digits). So each conversion is O(6) steps.

- Reverse the string: slicing is O(n), where n is the length of the string. Again, up to 6 steps.

- Concatenation: O(2n) steps.

- Convert to int: O(n), where n is the length of the concatenated string (up to 12 digits). But in practice, in Python, converting a string to an int is O(1) for numbers up to arbitrary size, but the actual steps may depend on the implementation.

So per iteration, it's about O(d) steps, where d is the number of digits of i. For i up to 1e5, d is up to 6. So per iteration, 6 steps. 1e5 * 6 steps is 6e5 operations, which is acceptable for Python in 2 seconds. Because Python can handle around 1e8 operations in a second (rough estimate). So 6e5 is way under that.

Therefore, this code should be efficient enough. Let's test it with the samples.

Sample 1:

Input: 2 100

Loop runs for i=1 and 2.

For i=1: s is '1' + '1' â†’ '11' â†’ 11.

For i=2: s is '2' + '2' â†’ '22' â†’ 22. Sum is 33. Mod 100 â†’ 33. Correct.

Sample 2:

Input:5 30.

Sum is 11+22+33+44+55=165. 165 mod30=15. Correct.

Another test case: k=1, p=anything. Output is 11 mod p.

So the code seems correct.

But what about the largest possible k? Let's say k=1e5.

But given that the code is O(k) time, it's acceptable.

Now, the problem is to optimize this code. Are there any possible optimizations?

Well, the code is already straightforward, but perhaps converting to string and then to integer can be optimized.

Alternative approach: generate the number numerically. For example, for a number n, the palindrome can be formed by appending the reversed digits. But how to compute that without strings.

But for a number like n, to create the reversed part, you can reverse its digits numerically and then compute the value as:

pal = n * 10^d + reversed(n), where d is the number of digits of n.

But reversing a number numerically requires a loop. For example, to reverse 12 into 21:

reverse_num = 0

original = 12

while original >0:

    reverse_num = reverse_num *10 + original%10

    original = original //10

So for 12, reverse_num is 21. Then, the palindrome is 12*100 +21= 1221.

But this approach could be faster than using strings? Maybe. Let's see.

But for n=1, the number of digits is 1. So 10^1 is 10. 1*10 + 1=11.

For n=10, digits=2. 10^2=100. 10*100 + 01 (reversed 10 is 01, but how to get that numerically? For n=10, reverse is 01, but as a number it's 1. So the code would need to reverse the digits, leading zeros are omitted. Wait, but that's a problem. Because when n is 10, the reverse is 01, but when you reverse it numerically, you get 1. So 10*100 +1 =1001, which is correct.

Yes. So the code would calculate:

n = 10.

digits = 2.

reverse_num = 0

temp =10

reverse_num = 0*10 + 0 (temp%10=0). temp becomes 1.

reverse_num =0*10 +1=1. temp becomes 0.

So reverse_num is 1. Then the palindrome is 10*100 +1 =1001.

Yes. So this works.

So the code can be written without using strings by:

For each i from 1 to k:

   compute the number of digits d in i.

   compute reverse_num of i (without leading zeros).

   palindrome = i * (10^d) + reverse_num.

   sum += palindrome.

So the challenge is to compute d (number of digits in i) and reverse_num for each i.

But how to compute this efficiently.

But in Python, even for i up to 1e5, the number of digits is up to 6, so reversing can be done in 6 steps per i.

But even with this, the code may not be faster than the string-based approach. Because in Python, string operations are optimized, and converting to a string and reversing is straightforward.

Alternatively, for each i, we can precompute the number of digits and the reversed number. But perhaps the code is more efficient if written with numerical operations instead of strings.

But for code brevity and clarity, the string approach is better. However, in terms of performance, maybe the numerical approach is better.

But let's see. For each i, how to compute d and reversed.

Here's a way to compute the reversed number and the number of digits:

def get_reversed_and_digits(n):

    reversed_num = 0

    d = 0

    temp = n

    while temp >0:

        reversed_num = reversed_num *10 + temp%10

        temp = temp //10

        d +=1

    return reversed_num, d

So for i=10, this function returns reversed_num=1, d=2.

Then, palindrome = i * (10**d) + reversed_num.

Yes. So for i=10: 10 * 10^2 (10*100=1000) +1 =1001.

Which is correct.

So for each i, we can compute the reversed_num and d, then calculate the palindrome.

So the code would look like:

sum_total =0

for i in range(1, k+1):

    rev, d = get_reversed_and_digits(i)

    pal = i * (10**d) + rev

    sum_total += pal

But for each i, the function get_reversed_and_digits runs in O(d) time, where d is the number of digits of i. For i up to 1e5, d is up to 6. So per iteration, 6 steps. For 1e5 iterations, that's 6e5 steps, which is manageable.

But in Python, the exponentiation (10**d) could be optimized. For d up to 6, 10**d is 1e6, which is easy.

But which approach is faster: using strings and converting to integers, or the numerical approach?

Testing in Python:

The string approach for each i would be:

pal = int(str(i) + str(i)[::-1])

Which is concise and, in Python, possibly optimized. The numerical approach requires computing the reversed number and digits, then calculating 10**d. But exponentiation is a O(1) operation for small exponents.

But perhaps the string approach is faster in Python, as string concatenation and conversion are highly optimized.

But for numbers like i=1e5, the string approach will generate '100000' + '000001' â†’ '10000000001', which when converted to integer is 10000000001. The numerical approach would compute rev=1 (since reversing 100000 gives 000001, but as a number it's 1), d=6. Then pal=100000 * 10^6 +1 â†’ 100000 * 1e6 is 1e11 +1 â†’ 10000000001. Which is correct.

So both approaches generate the same result.

Comparing the two approaches in code:

The original code with strings is straightforward and easy to write, and in Python, string operations are fast. So perhaps the string-based approach is better here for code simplicity and speed.

But for very large k (like 1e5), which approach is better?

Let's think about the steps:

In the string approach, for each i:

- Convert to string: O(d) steps.

- Reverse the string: O(d) steps (since the string is of length d).

- Concatenate the two strings: O(2d) steps (creating a new string of length 2d).

- Convert to integer: O(2d) steps (parsing the string into an integer).

In the numerical approach, for each i:

- Compute reversed_num and d: O(d) steps.

- Compute 10**d: O(1) (as d is small).

- Multiply i by 10^d and add reversed_num: O(1) operations (for numbers up to 1e5 * 1e6 + 1e5 â†’ ~1e11, which is manageable in Python's integers).

So for each approach, per iteration, it's O(d) steps. But in practice, string operations are optimized in Python's C-level code, so even though the steps are O(d), the constants are lower.

For example, the code 'str(i)' is handled by a highly optimized function. Similarly, string reversal via slicing is very fast.

Thus, the string-based approach is likely to be faster in Python for this problem, especially for larger values of k.

Therefore, the original code using strings is probably the best approach here.

But let's check for possible optimizations. For example, precomputing the reversed part as a string.

Wait, when you reverse a string in Python, s[::-1] is O(n) time. But for small n (like up to 6 digits), it's negligible.

Another thing to note is that for very large k, the generated numbers can be very large (up to 1e5 digits?), but in our case, k is up to 1e5, which for each i, the generated palindrome is 2*log10(i) digits. For i=1e5, it's 6 digits, so palindrome is 12 digits. Summing up 1e5 numbers of 12 digits each would be a total of 1e5 * 12 digits, which is manageable in Python's big integers. Summing them up would be feasible.

So the code as written is correct and efficient.

Now, considering memory constraints. The code uses O(1) variables (sum_total is a single integer, and each palindrome is generated and added to sum_total in a loop, so no storage of all k palindromes). So even for k=1e5, it uses minimal memory. Therefore, the code is memory-efficient.

Therefore, the code as written is optimal for the given problem constraints.

So the final code would be:

Read k and p.

Initialize sum_total =0.

For i from 1 to k:

    s = str(i) + str(i)[::-1]

    sum_total += int(s)

Output sum_total % p.

Yes.
</think>

```python
k, p = map(int, input().split())
sum_total = 0
for i in range(1, k + 1):
    s = str(i) + str(i)[::-1]
    sum_total += int(s)
print(sum_total % p)
```
