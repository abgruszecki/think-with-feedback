<think>
Okay, I need to find the first occurrence of a given Fibonacci number modulo 1013. Let's think about how to approach this problem.

First, the Fibonacci sequence modulo m (here, m=1013) is periodic. This is known as the Pisano period. But since we're looking for the first occurrence of a specific value f, maybe we don't need to compute the entire period. But how do we efficiently find where f appears for the first time?

The problem is to generate the Fibonacci sequence modulo 1013 until we find f, but since 1013 is a modulus, the sequence will eventually repeat. However, the first occurrence of f could be before the Pisano period starts repeating. So, perhaps the best approach is to generate the sequence up to a certain point and track the positions of each value. If a value repeats, then we can stop and determine if f was found or not.

Wait, but the Pisano period for modulus m is the period after which the sequence repeats. But the initial terms could have duplicates. For example, 0,1,1, etc. So even if a value appears again later, the first occurrence is the one we need.

So the plan is: generate the Fibonacci sequence modulo 1013, keeping track of each value's first occurrence. Once we encounter a pair of consecutive numbers (like 0 and 1) that we've seen before, we know that the sequence is starting to repeat. At that point, if we haven't found f by then, it will never appear again. So we can stop.

But how to detect that the sequence is about to repeat? The Pisano period starts with 0, 1. So if we ever get two consecutive terms 0 and 1 again, the sequence will repeat. So we can check each pair of consecutive terms. When we see (0,1) again after the start, that's when the cycle repeats.

So here's the approach:

- Precompute the sequence until we hit the pair (0,1) again. For each term in the sequence, record the position of the first occurrence of each value.
- Once the cycle is detected, stop.
- Then, check if f was in the recorded positions. If yes, return the earliest position. Else, return -1.

But wait, the Pisano period for modulus 1013 might be very large. What's the maximum possible length we need to check?

The Pisano period for a prime p can be up to p^2 -1. But 1013 is a prime, right? Let's check: 1013 divided by primes. Well, assuming it's a prime. So the Pisano period could be up to 1013^2. Which is around a million. 1013^2 is 1,026,169. So if we have to compute up to a million terms, that's manageable. Because even a million iterations are fast in Python for a single test case.

So the steps are:

1. Generate the Fibonacci sequence modulo 1013, keeping track of each value's first occurrence.
2. For each term generated, check if the current and previous term are 0 and 1. If yes, stop.
3. After generating, check if f is in the map of first occurrences. If yes, output the earliest index. Else, -1.

So, let's think about the data structures. We can use a dictionary to store the first occurrence of each value. Also, we need to generate the sequence:

Initialize a list or variables for the previous two terms. Start with a=0, b=1 (positions 0 and 1). Then for each next term, compute (a + b) mod 1013. Then shift a and b.

But during generation, for each term (after the initial ones), we need to check if a pair (a, b) is (0,1). Because that's the start of the cycle. Wait, the initial pair is (0,1) at positions 0 and 1. The next term is (1, 1) (position 2), then (1,2) (position 3), etc. So when we generate a new term, the next pair is (b, new_term). So for each step, after generating the new term, we check if the current pair (b, new_term) is (0,1). If yes, then the next term would be 1 again, and the sequence repeats.

Wait, perhaps I need to track the current pair (a, b). Let me see:

The Fibonacci sequence is generated by:

fib[0] = 0
fib[1] = 1
fib[n] = (fib[n-1] + fib[n-2]) mod 1013 for n >= 2.

So, for each step, the next term is the sum of the previous two. So during iteration, we can keep track of the previous two terms. Let's say we have a and b, which are fib[n-1] and fib[n]. Then the next term is (a + b) mod 1013, which is fib[n+1]. Then, the next pair becomes (b, next_term). So after each step, the pair (a, b) represents the previous two terms.

The starting pair is (0, 1) for positions 0 and 1. Then, after generating position 2, the pair is (1, 1). So, during iteration, each new term is added, and the pair (a, b) is updated to (b, next_term).

Therefore, the Pisano period starts when the pair (a, b) returns to (0, 1). So, during iteration, after generating each new term (say, for position n), we check if the new pair (b, next_term) is (0, 1). If yes, then we know that the sequence will repeat from here. So, the next terms after that will start the cycle again. Thus, we can stop generating terms once we detect this.

So the algorithm steps:

- Initialize a dictionary (first_occurrence) to store the first occurrence index of each value.
- Add fib[0] = 0 at index 0.
- Add fib[1] = 1 at index 1.
- Check if the input f is 0 or 1. If so, return 0 or 1 (but wait, for 1, the first occurrence is index 1? Wait, looking at the example, the first occurrence of 1 is index 1. But wait, the sequence is 0, 1, 1, 2, 3, etc. So the first 1 is at index 1, and the next at index 2. So in first_occurrence, 1's first occurrence is index 1. So the initial step is to set first_occurrence[0] = 0, first_occurrence[1] = 1.

Then, for the next terms:

- The current a and b are 0 and 1 (positions 0 and 1). Then, the next term (position 2) is (0 + 1) mod 1013 = 1. So pair becomes (1, 1). Then check if (1,1) is (0,1)? No. Then check if 1 is in first_occurrence. Since it's already present (index 1), we don't update.

Then, position 3: next term is (1 + 1) mod 1013 = 2. Check if 2 is in first_occurrence. No, so add index 3. Then pair becomes (1, 2).

Continue this process until the current pair (a, b) becomes (0,1) again. Because then, the next term will be 1, which is the same as position 1. So the sequence will repeat.

So the loop will run until we generate the next term and check if the new pair (a, b) is (0,1). If yes, then we can stop.

Thus, the algorithm is:

Initialize first_occurrence as {0:0, 1:1}

current index is 2 (since we have processed 0 and 1, next is 2).

a = 1 (fib[1])
b = 1 (fib[2])
so the pair (a, b) is (1, 1). This is not (0,1), so we proceed.

Then, for each step:

Compute next term = (a + b) mod 1013.

Check if next term is already in first_occurrence. If not, add it with current index.

Then check if the new pair (b, next_term) is (0, 1). If yes, break.

Otherwise, update a to b, b to next_term, increment index, and loop.

So, the steps would be:

prev1 = 1 (fib[1])
prev2 = 1 (fib[2])
next_term = (1+1) mod 1013 = 2. So fib[3] is 2. Check if 2 is in first_occurrence. Add 3:2.

Check if (prev2, next_term) is (0,1). prev2 is 1, next_term is 2. No. So proceed.

Update a = prev2 (1), b = next_term (2). index becomes 4.

Now next term is (1+2) mod 1013 =3. Add to first_occurrence if needed. Then check if (2, 3) is (0,1). No.

Continue until when the pair (a, b) becomes (0,1) again.

Once that happens, stop generating terms. Then, check if f is in first_occurrence. If yes, return the value. Else, return -1.

This approach ensures that we generate all possible terms up to the point where the cycle starts again. So if f is present in the sequence, it must have appeared before the cycle starts again, otherwise it's not present.

Now, the maximum possible steps we need to take is up to the Pisano period for modulus 1013. Since 1013 is a prime, the Pisano period could be as large as O(1013^2) = 1 million. So even for 1e6 steps, in Python, that's manageable.

So, the code structure would be:

Read f.

If f is 0: return 0.

If f is 1: return 1.

Else:

Initialize first_occurrence as {0:0, 1:1}

prev1, prev2 = 1, 1 (fib[1] and fib[2])

index = 2 (since next term is fib[3], which is index 3?)

Wait, wait. Let's think about the indexes.

fib[0] = 0, index 0.

fib[1] = 1, index 1.

fib[2] = (0 +1) mod 1013 =1, index 2.

fib[3] = (1 +1) mod 1013=2, index 3.

fib[4] = (1 +2) mod 1013=3, index4.

So, in the code:

We start with prev1 = fib[1] =1 (index1), prev2 = fib[2] =1 (index2). Then, for the next term (fib[3]), which is index3.

Wait, the variables in the code:

prev1 and prev2 are the previous two terms. So for each iteration, the next term is prev1 + prev2 mod m.

So:

After the initial terms (index 0 and 1), index is 2 for the next term (fib[2]).

Wait, maybe I should track the index correctly.

Wait, the code steps:

Initialize first_occurrence with {0:0, 1:1}.

Then, for the next terms starting at index 2 (fib[2] = 1). So prev1 = fib[0] =0? Wait, maybe I messed up the initial variables.

Wait, perhaps it's better to track the previous two terms as (a, b), where a is fib[i-1], and b is fib[i]. Then, the next term is a + b.

So, for the first step after initial setup:

i starts at 2, since fib[2] is the next term.

Wait, let's outline the variables:

Initialize a = 0 (fib[0])

b = 1 (fib[1])

index = 0 and 1 are already processed.

We need to generate terms starting from index 2.

So, first_occurrence contains 0:0 and 1:1.

Then, for index 2:

next_term = (a + b) mod 1013 â†’ (0 +1) mod 1013 = 1.

Check if 1 is already in first_occurrence. It is (index1), so do not add. Then check if (b, next_term) is (0,1). Here, b is 1, next_term is 1. So the new pair is (1,1). Not equal to (0,1). So proceed.

Add index2 to the first_occurrence if 1 is not present. But since 1 is already there, we don't.

Then, a becomes b (1), b becomes next_term (1). index increments to 3.

Now, for index3: next_term is (1+1)=2 mod 1013. Check if 2 is in first_occurrence. If not, add index3. Then check if (1, 2) is (0,1). No. Proceed.

So, the code's variables:

a and b start as 0 and 1 (fib[0] and fib[1]).

index starts at 2.

Wait, but index is the position of the next term. For example:

term 0: a=0 (index0)

term1: b=1 (index1)

term2: a + b =1 â†’ index2.

So, for each iteration:

next_term = (a + b) mod m.

We process index as the current term's index (i), which starts at 2.

Then, check if next_term is in first_occurrence. If not, add it.

Then, check if (b, next_term) is (0,1). If yes, break.

Then, update a = b, b = next_term. index +=1.

So, in code:

m = 1013

f = input value.

if f ==0: return 0.

if f ==1: return 1.

Else:

create a dictionary, first_occurrence = {0:0, 1:1}

a, b = 0, 1

index =2

loop:

next_term = (a + b) % m

if next_term not in first_occurrence:

    first_occurrence[next_term] = index

if (b, next_term) == (0,1):

    break

a, b = b, next_term

index +=1

So, after generating next_term, which is fib[index], we check if the new pair (b, next_term) is (0,1). If yes, the next terms will repeat the sequence from the start.

Once the loop breaks, check if f is in first_occurrence. If yes, output the value. Else, -1.

But wait, the first_occurrence is built only for the terms generated before the cycle starts. So if the input f is present in the sequence before the cycle repeats, then it's captured. Otherwise, it's not present.

This seems correct.

Now, what about the maximum possible steps? The loop runs until the pair (b, next_term) becomes (0,1). The maximum number of steps would be the Pisano period minus the first two terms. Because the Pisano period starts with 0,1 and then starts repeating. So the number of terms in the Pisano period is the number of steps from 0,1 until the next 0,1.

But according to the code, the loop will generate terms until the next pair (b, next_term) is (0,1). So the number of terms generated after the initial 0 and 1 is up to the Pisano period's length.

For m=1013, which is a prime. The Pisano period for a prime p can be either p-1 or p+1, or factors thereof, depending on whether 5 is a quadratic residue modulo p. But I'm not sure. However, even if it's 1e6 steps, in Python it's manageable.

Testing with the examples:

First example input:13. Let's see.

The list modulo 1013 would have 13 at some position. Let's see:

The sample output is 7. Which aligns with the example given.

Another example:377. Since 377 mod 1013 is 377. The 14th position.

So the code should handle these.

Now, in code:

Read f from input. Then proceed.

Edge cases:

- f=0: output 0.

- f=1: output 1.

- f is not present in the sequence: output -1.

But when is a number not present in the sequence? For example, suppose m is 1013. Are all residues possible?

Not necessarily. For example, in the Fibonacci sequence modulo 4, the sequence is 0,1,1,2,3,1,0,1,1, etc. So some residues like 3 appear once, others may not appear.

Thus, the code must check if f is in the first_occurrence dictionary.

So the code steps:

Read f from input.

If f not in first_occurrence after generating all possible terms, return -1.

Now, implement this.

But wait: when we start, the first_occurrence is {0:0, 1:1}. For the next terms, only add them to first_occurrence if not present. So the first occurrence of each term is correctly recorded.

So the code is correct.

Now, code in Python:

But in Python, we need to read f as an integer. Let's code:

Read f = int(input())

if f ==0: print(0)

elif f ==1: print(1)

else:

    create the first_occurrence dict, then process.

But wait, the code for the else part.

But in code:

Testing against sample input 1.

```python
def main(input_stream, output_stream):
    m = 1013

    f = int(input_stream.readline().rstrip("\n"))

    if f == 0:

        print(0, file=output_stream)

    elif f ==1:

        print(1, file=output_stream)

    else:

        first_occurrence = {0: 0, 1:1}

        a, b = 0, 1

        index = 2

        found = False

        while True:

            next_term = (a + b) % m

            if next_term == f and next_term not in first_occurrence:

                first_occurrence[next_term] = index

            # Check if next_term is new, add to dict

            if next_term not in first_occurrence:

                first_occurrence[next_term] = index

            # Check if the new pair is (0,1)

            if b ==0 and next_term ==1:

                break

            a, b = b, next_term

            index +=1

        if f in first_occurrence:

            print(first_occurrence[f], file=output_stream)

        else:

            print(-1, file=output_stream)



def test():
    import io

    TEST_CASES = [
        {
            "input": \
"""\
377
""",
            "output": \
"""\
14
""",
        }, 
    ]

    for i, test_case in enumerate(TEST_CASES):
        in_stream = io.StringIO(test_case["input"])
        expected_output = test_case["output"].rstrip()

        out_stream = io.StringIO()
        main(in_stream, out_stream)
        real_output = out_stream.getvalue().rstrip()

        assert real_output == expected_output, \
            f'Test case {i} failed.\nExpected: {expected_output!r}\nGot: {real_output!r}'

    print('Tests passed ðŸ˜Ž')


if __name__ == '__main__':
    test()


```

<RUN_SNIPPET>
```output
Tests passed ðŸ˜Ž

```

Another sample:377 mod 1013 is 377. Let's see when 377 occurs. The 14th position is correct.

But how does the code capture that? Let's see:

The code would generate up to when the pair (b, next_term) is (0,1). So during the loop, when the next_term is 377, it's added to the dict. Then when the loop breaks, the code checks if 377 is in the dict. If yes, returns the index.

So the code should handle that.

Now, what about if the code generates up to the cycle start. For example, if the input is 0, it's already handled. For inputs that are not present, like suppose m=4, and f=3. The sequence would have 3 once, but then it would never appear again. So the code would find it.

Thus, the code should be correct.

But wait, in the code, the loop runs until the next pair is (0,1). So the next_term is 1, and b is 0.

But in the initial case, the pair (0,1) is only the first two terms. The code starts with a=0, b=1, and index=2. So the first iteration's next_term is 1. Then (b, next_term) is (1, 1). Then a=1, b=1. Index becomes3.

The next_term is 2. (b, next_term) is (1,2). So the loop continues until at some point, after generating a term next_term, the pair (b, next_term) is (0,1). Then the loop breaks.

Thus, the code correctly detects when the cycle is about to start again.

Now, the code may generate up to m^2 terms. For m=1013, that's about 1e6 iterations. Which is acceptable in Python for time constraints.

Testing the code with the samples:

Sample 1:

Input:13 â†’ output7.

Sample 2:

Input:377 â†’ output14.

Thus, the code should handle these.

Now, code in Python:

But wait, in the code, the loop is while True. So how does it break?

The code checks if (b ==0 and next_term ==1). If so, breaks.

Thus, the code should work.

Now, let's code this correctly.

But also, the code must read the input and output accordingly.

Here's the code:

Read f as integer.

Check if f is 0 or 1, output accordingly.

Else:

Initialize first_occurrence with 0 and 1.

Then loop.

Thus, the code is:

m = 1013

f = int(input())

if f == 0:

    print(0)

elif f == 1:

    print(1)

else:

    first_occurrence = {0: 0, 1: 1}

    a, b = 0, 1

    index = 2

    while True:

        next_term = (a + b) % m

        # Add to first_occurrence if not present

        if next_term not in first_occurrence:

            first_occurrence[next_term] = index

        # Check if current pair (b, next_term) is (0,1)

        if b == 0 and next_term == 1:

            break

        a, b = b, next_term

        index += 1

    # Check if f is in first_occurrence

    print(first_occurrence.get(f, -1))

Wait, but wait: in the code, for f=1, the first occurrence is index1, but in the problem statement, the first occurrence is at index1. So the code correctly returns 1.

For example, if f=1, the code returns 1.

Another example: if the input is 1, output is 1.

But what about the second occurrence of 1, which is index2? The code doesn't capture that, but since the first_occurrence already has 1 mapped to index1, the code is correct.

Thus, the code should work.

Now, testing the code for the second example, input 377:

377 is part of the Fibonacci sequence. Let's see:

The 14th term (0-based index) is 377.

But let's see:

fib[14] is 377.

But modulo 1013, since 377 is less than 1013, it's 377. So the code will assign index14 to 377.

Thus, the code should output 14.

Thus, the code works.

So the code is correct.
</think>

```python
m = 1013
f = int(input())
if f == 0:
    print(0)
elif f == 1:
    print(1)
else:
    first_occurrence = {0: 0, 1: 1}
    a, b = 0, 1
    index = 2
    while True:
        next_term = (a + b) % m
        if next_term not in first_occurrence:
            first_occurrence[next_term] = index
        if b == 0 and next_term == 1:
            break
        a, b = b, next_term
        index += 1
    print(first_occurrence.get(f, -1))
```
