<think>
Okay, so I need to solve this problem where I have to determine if Kefa's and Sasha's tracks are the same, just with different starting points. Let me think about the problem carefully.

The problem says that two tracks are considered the same if one can be obtained from the other by shifting the starting point. So, essentially, the barriers are arranged in a circular way, and shifting the start would rotate the positions. But how do I check if two sequences of barrier distances (from their respective starts) can be rotations of each other?

Let me consider the example given. For the first sample input:

Kefa's barriers are [2,4,6], Sasha's are [1,5,7]. The track length is 8. The actual positions of the barriers in the circle could be, for example, at positions 2,4,6 when starting from Kefa's start point. But if the start point is shifted by, say, 7 units (since L is 8, shifting by 7 is like moving one step counterclockwise around the circle), then Sasha's start is 7 units away from Kefa's. So each of Kefa's barriers would be 2+7=9 mod 8=1, 4+7=11 mod8=3? Wait, wait, maybe I need to think differently. Because when the start shifts, all barriers' positions are shifted by the same amount modulo L.

Wait, let's clarify. Suppose the actual barrier positions (fixed on the track) are some points. Kefa's start is at position S, and Sasha's start is at position T. Then, for each barrier B_i, the distance from S is (B_i - S) mod L. Similarly for T, it's (B_i - T) mod L. But since the track is circular, when they list the distances from their own starts, those lists are the same if the actual barrier positions are the same set, but the start points are different.

Wait, no. Wait, the problem states that the track is the same if the positions of all barriers are the same. So the two sequences (Kefa's and Sasha's) must correspond to the same set of barriers but viewed from different starting points.

So the problem reduces to: given two sequences A and B (each sorted), check if there exists a shift d such that when each element in A is shifted by d modulo L, the resulting set (when sorted) matches the B sequence.

Alternatively, the problem can be rephrased as: can we find a shift d such that for every a in Kefa's list, (a + d) mod L is in Sasha's list, and vice versa (since sets must match exactly). Because the barriers are the same, just viewed from a different start point.

But how do I compute that shift d?

Let's think: the possible shifts d are the differences between some element in B and some element in A. Because for the shift d to align an element a_i in A to an element b_j in B, d must be (b_j - a_i) mod L. Then, for this d, we need to check if all elements in A, when shifted by d, are present in B (and the same number, since duplicates are not possible as per input constraints).

But the problem says that Kefa's and Sasha's lists are in ascending order, and all elements are distinct. Also, n can be up to 50, which is manageable.

So the steps could be:

1. For each possible pair of a_i (from Kefa's list) and b_j (from Sasha's list), compute the candidate d = (b_j - a_i) mod L.

2. For each candidate d, check if shifting all elements of Kefa's list by d modulo L results in a multiset that exactly matches Sasha's list.

3. If any such d exists, output YES. Otherwise, NO.

But how many candidate d's are there? For each of the n elements in A, paired with each of the n elements in B, that's n² possibilities. Since n is up to 50, 50²=2500 possibilities. For each of these, we need to check all n elements of A shifted by d, and see if they are all present in B. But checking can be done efficiently by converting B into a set (since elements are unique) and then for each shifted a_i, check if it's in the set. Then, also check that the size is the same, which it is since n is the same.

Wait, but the set of shifted elements must exactly match B. So for each candidate d, shift all elements in A by d mod L, sort them, and see if they equal B's sorted list (which they are already given in sorted order). Wait, but B is given in sorted order. So after shifting A's elements by d mod L, we need to sort them and check if they match B's list.

Alternatively, since the elements are sorted in B, perhaps after shifting all elements in A by d mod L, the sorted list of these shifted elements must equal B's list.

So the steps are:

For each possible d in the candidate d's (generated by pairs a_i and b_j):

- Take each element a in Kefa's list, compute (a + d) mod L. Collect all these values.

- Sort this new list.

- Check if the sorted list equals Sasha's list.

If any of these checks pass, return YES.

Otherwise, check the reverse: maybe shifting Sasha's list by some d and comparing to Kefa's list? Wait no, because if shifting Kefa's list by d gives Sasha's list, then shifting Sasha's list by -d mod L would give Kefa's list. So checking all possible d's from Kefa to Sasha is sufficient.

But why? Because the problem asks whether there exists a d such that shifting Kefa's list by d gives Sasha's list, which is equivalent to the track being the same. So for each possible candidate d, we need to check that.

So the algorithm is:

- Generate all possible candidate shifts d as (b_j - a_i) mod L, for all a_i in A, b_j in B.

- For each d, check if shifting all elements in A by d mod L and sorting gives B.

- Also, check if shifting all elements in B by d' mod L (where d' is (a_i - b_j) mod L) gives A. Wait, no, because if shifting A by d gives B, then shifting B by (L -d) mod L gives A. So considering all possible d's from A to B is sufficient.

Wait, but perhaps some d's not generated by pairs (a_i, b_j) could also work. For example, if all barriers are equally spaced, then the shift might be a step between two barriers. But given that the problem allows L up to 100, perhaps generating all possible d's is feasible.

Wait, but for L up to 100, there are only 100 possible shifts. So even if we generate all possible shifts from 0 to L-1, and check each, that would be 100 iterations. For each iteration, shifting A's list by d mod L, sort, compare to B. For n=50, this is 50 elements to shift, sort (O(n log n)), and compare. 100 * 50 log 50 operations is negligible. So perhaps the approach can be simplified.

But why are the candidate shifts generated by (b_j - a_i) mod L? Because for a shift d to align some a_i with b_j, that's the required d. However, other shifts could also work if the entire sequences match. But perhaps the number of possible shifts to check can be reduced by considering the pairs (a_i, b_j). Because if a correct shift exists, then for that shift, each a_i in A must be shifted to some b_j in B. So the correct shift must be (b_j - a_i) mod L for at least one pair (a_i, b_j). Therefore, generating all possible candidate shifts from the pairs (a_i, b_j) is sufficient, because the correct shift must be one of them.

Wait, let's suppose there's a correct shift d. Then, for each a in A, (a +d) mod L is in B. So for each a_i in A, (a_i +d) mod L is some b_j in B. So for each a_i, there is a corresponding b_j such that d = (b_j - a_i) mod L. So the correct d must be one of the possible (b_j - a_i) mod L for some a_i and b_j. Therefore, generating all possible (b_j -a_i) mod L for all a_i, b_j pairs gives all possible candidate shifts. So checking all these shifts is sufficient.

So, the steps are:

1. Read n, L.

2. Read Kefa's list (A) and Sasha's list (B), both sorted.

3. For each element a in A, and for each element b in B:

   a. Compute d = (b - a) mod L.

   b. Check if shifting all elements in A by d mod L gives a sorted list equal to B.

4. If any such d exists, output YES. Otherwise, output NO.

But also, maybe we need to check shifts in the other direction. Wait, no. Because if shifting A by d gives B, then shifting B by (L-d) mod L gives A. But the problem allows either direction. Wait, but the problem is to check whether the two tracks are the same. So if the answer is YES, then there exists a shift d such that A shifted by d equals B. So checking all possible d's derived from (b_j - a_i) mod L is sufficient.

So for the code:

We can generate all possible d's from the pairs (a_i, b_j), then for each d, check if shifting A by d and sorting gives B.

But since A and B are already sorted, perhaps after shifting, when we sort the shifted A, it should equal B's sorted list (which is already sorted). But when we shift each element in A by d, since the list is sorted, adding d (mod L) could wrap around. So the shifted list might not be sorted anymore. So we need to sort the shifted list and then compare to B.

For example, in the first sample input:

A is [2,4,6], B is [1,5,7]. Let's take a_i=2 and b_j=1. Then d = (1-2) mod 8 = (-1 mod 8) =7. Then shifting each element in A by 7 gives (9 mod8=1, 11 mod8=3, 13 mod8=5). But [1,3,5] sorted is [1,3,5], which is not B. Wait, but in the sample input, the correct answer is YES. So perhaps the example's correct d is 7. Wait, but sample input's B is [1,5,7]. Hmm, that's conflicting.

Wait, the first sample input's B is [1,5,7]. So how does the shifting work here?

Wait, in the example given, the barriers are at positions 2,4,6 when Kefa starts. But Sasha's start is shifted by 7 units (since 2+7=9 mod8=1, 4+7=11 mod8=3, 6+7=13 mod8=5. So those would be [1,3,5], but B's list is [1,5,7]. Wait, that's not matching. So perhaps I made a mistake here.

Wait, maybe the actual shifting is not adding, but subtracting. Because the distance from the start to the barrier is the position of the barrier minus the start position, mod L. So the actual positions of the barriers are (a + start) mod L. Wait, no. Let's think again.

Wait, the problem states that each barrier is located at a certain integer distance from the start along the track. So the start is position 0. Then, each barrier's position is exactly the distance value. So if the start is moved to a new position S, then each barrier's position (relative to the new start) is (original barrier position - S) mod L.

So the actual barrier positions in the track are fixed. So when Kefa's start is S, the distances are (B_1 - S) mod L, (B_2 - S) mod L, etc. When Sasha's start is T, the distances are (B_1 - T) mod L, etc. So the two sequences must be the same set of (B_i - S) mod L and (B_i - T) mod L. So the two sequences must be related by a shift of (T - S) mod L, because (B_i - T) mod L = (B_i - S - (T - S)) mod L = ((B_i - S) mod L - (T - S) mod L) mod L. So this is equivalent to subtracting (T - S) mod L from each element of Kefa's list (mod L). So the shift between the two sequences is (T - S) mod L. Wait, no. Wait, for each barrier B_i:

In Kefa's list, it's (B_i - S) mod L.

In Sasha's list, it's (B_i - T) mod L.

So (B_i - T) mod L = ((B_i - S) + (S - T)) mod L = (A_i + (S - T)) mod L? No. Wait, (B_i - T) = (B_i - S) - (T - S). So mod L, that's (A_i - d) mod L, where d = (T - S) mod L.

So Sasha's list is (A_i - d) mod L for each element in Kefa's list.

Wait, this is getting a bit confusing. Let me rephrase.

If the actual barrier positions are B_1, B_2, ..., B_n, then Kefa's start S is such that for each barrier B_i, the distance is (B_i - S) mod L. Similarly, Sasha's start T gives distances (B_i - T) mod L. So the two sequences (A and B) must be such that B's elements are (A_i - d) mod L, where d = (T - S) mod L. Because T = S + d mod L. So Sasha's start is S + d mod L.

But how do we relate the two sequences?

For example, if Kefa's list is A = [a_1, a_2, ..., a_n], sorted in ascending order, then Sasha's list B must be a permutation of (a_1 - d) mod L, (a_2 -d) mod L, ..., (a_n -d) mod L, sorted.

Wait, no. Because when you subtract d from each a_i and mod L, the sorted list may not be in the same order. For example, suppose L=8, d=7, and A is [2,4,6]. Subtracting 7 mod8 gives (2-7) = -5 mod8 =3, (4-7)= -3 mod8=5, (6-7)= -1 mod8=7. So the list becomes [3,5,7], sorted, which is B in the sample input. So in that case, the sample input B is [1,5,7]? Wait, no, the first sample's B is [1,5,7]. Hmm, maybe there's confusion here.

Wait, the first sample input:

Kefa's list is [2,4,6], Sasha's is [1,5,7], L=8.

The correct answer is YES. So how does this fit?

Ah, perhaps the actual shift here is (1 - 2) mod8 = -1 mod8=7. So shifting each element in Kefa's list by 7 gives (2+7) mod8=9 mod8=1, (4+7)=11 mod8=3, (6+7)=13 mod8=5. So the shifted list would be [1,3,5], which when sorted is [1,3,5]. But Sasha's list is [1,5,7]. So that doesn't match. Hmm, this suggests that my earlier reasoning is incorrect.

Wait, this is conflicting with the sample input. What's wrong here?

Ah! Wait, perhaps the shift is not added to Kefa's list, but subtracted. Because in the example, the actual barrier positions are 2,4,6. So when Sasha's start is at position 7 (since Kefa's start is 0, perhaps?), then the distances for Sasha would be (2-7) mod8 = ( -5 mod8)=3, (4-7)= -3 mod8=5, (6-7) =-1 mod8=7. So the distances would be 3,5,7. But the sample's Sasha's list is [1,5,7]. So that's not matching. So there's something wrong here.

Wait, perhaps the way the start position relates to the barrier positions is different. Maybe the distance is the position from the start along the track in the counterclockwise direction. So the actual barrier positions are (start + distance) mod L. For example, Kefa's start is S. The barriers are at (S + a_1) mod L, (S +a_2) mod L, etc. Then Sasha's start is T, and the barriers are (T + b_1) mod L, etc. But for the two sets of barriers to be the same, the set {S +a_1, S +a_2, ...} mod L must equal {T +b_1, T +b_2, ...} mod L.

But since the problem states that the actual barrier positions are the same for both tracks (if they are the same track), then the multiset of (S +a_i) mod L must equal the multiset of (T +b_i) mod L. So the two sequences of (a_i) and (b_i) must be such that there exists a delta (delta = T - S mod L) such that for all a_i, (a_i + S) mod L = (b_j + T) mod L. Which can be rearranged as (a_i + S) mod L = (b_j + T) mod L. Then, S - T mod L = b_j -a_i mod L. So delta = (S - T) mod L = (a_i - b_j) mod L. So for some a_i and b_j, delta must be (a_i - b_j) mod L.

But how does this help us?

Alternatively, the set of barrier positions is the same, so { (a_1 + S) mod L, ..., (a_n + S) mod L } must equal { (b_1 + T) mod L, ..., (b_n + T) mod L }.

So for the two to be the same, there must exist a delta such that (a_i + S) mod L = (b_j + T) mod L. So the delta between T and S is (a_i - b_j) mod L for some i,j.

But how do we check this?

Alternatively, the two sets must be the same, so there's a rotation of the list such that when you rotate the barriers (as positions) by some delta, you get the other list. But since the barriers are in a circle, this delta can be found by comparing the possible differences between the elements.

Hmm, perhaps this approach is not leading me anywhere. Let me think differently.

The problem is to check if the two lists A and B can be transformed into each other via a cyclic shift. So the solution is to generate all possible cyclic shifts of one list and see if any matches the other.

But how to represent a cyclic shift here. For example, in a circular track, the barriers can be arranged in a certain order. So the list A represents the distances from a starting point S, and list B represents the distances from a starting point T. So the actual positions of the barriers are S + a_i mod L for each a_i in A, and T + b_i mod L for each b_i in B. These two sets must be the same.

Thus, the problem reduces to: is there a delta (T - S) mod L such that { (S + a_i) mod L } = { (T + b_i) mod L } for all i.

But how to find delta?

The set { (S + a_i) mod L } = { (T + b_i) mod L } implies that (S + a_i) mod L must be congruent to (T + b_j) mod L for some permutation of j. So for each i, there exists j such that S + a_i ≡ T + b_j (mod L). Which can be rewritten as (S - T) ≡ (b_j - a_i) (mod L). So delta = S - T ≡ (b_j - a_i) mod L.

But delta is the same for all i. So for all elements a_i in A, there exists a corresponding b_j in B such that (b_j - a_i) mod L equals delta.

But how to find this delta?

For each possible pair (a_i, a_0) in A and (b_j, b_0) in B, compute delta_candidate = (b_j - a_i) mod L. Then check whether for this delta_candidate, all elements in A shifted by delta_candidate (i.e., (a + delta_candidate) mod L) are present in B.

Wait, no. Wait, if delta is (S - T) mod L, then T = S - delta mod L. So the actual barrier positions from S's perspective are (S + a_i) mod L. From T's perspective, the positions are (T + b_k) mod L. For these to be equal, (S +a_i) mod L must equal (T + b_k) mod L for some permutation. Substituting T = S - delta mod L, we get:

S +a_i ≡ S - delta + b_k mod L.

Simplifying: a_i ≡ b_k - delta mod L.

Rearranged: b_k ≡ a_i + delta mod L.

So for each a_i in A, there must be a b_k in B such that b_k = (a_i + delta) mod L. So delta is the difference between some b_k and a_i, modulo L. Thus, delta can be any (b_k - a_i) mod L for some i and k.

Thus, the possible delta candidates are all possible (b_j - a_i) mod L for each a_i in A and b_j in B. For each such candidate delta, we need to check that for every a in A, (a + delta) mod L is in B.

But since B is a sorted list, perhaps the best approach is:

For each candidate delta (from all possible pairs a_i and b_j), check if every a in A, when added delta mod L, is present in B. And also, that the size of B is the same (which it is, since n is fixed).

But how to check if (a + delta) mod L is present in B.

Since B is sorted, we can convert it into a set for O(1) lookups. For example:

Convert B into a set. For each a in A, compute (a + delta) mod L and check if it's in the set. If all are, then YES.

But wait, the order of elements in B doesn't matter here, because the actual positions are a set. Wait, but the problem says that the two sequences must be the same after shifting. So the shifted A must, when sorted, equal B's sorted list. Because in B's list, the elements are sorted in ascending order. So even if the shifted A's elements are a permutation of B's elements, when sorted they must be the same.

So the correct approach is:

For each candidate delta:

1. Shift each element a in A by delta mod L, resulting in (a + delta) mod L.

2. Sort the resulting list.

3. Check if this sorted list equals the B list.

If any delta satisfies this, output YES. Else, NO.

So the steps are:

- Generate all possible delta candidates as (b_j - a_i) mod L for all a_i in A, b_j in B.

- For each delta, compute the shifted list, sort it, and check against B.

- If any of these checks pass, return YES. Otherwise, return NO.

But what about delta candidates not generated by (a_i, b_j) pairs? Could there be a delta that works but is not generated by any pair?

No. Because if there's a delta that works, then for each a in A, (a + delta) mod L is in B. So for each a in A, there's a corresponding b in B such that delta = (b - a) mod L. So delta must be one of the possible (b_j - a_i) mod L for some pair (a_i, b_j). Therefore, generating all such delta candidates covers all possibilities.

Therefore, the approach is correct.

So in code:

Read n and L.

Read A as list of integers.

Read B as list of integers.

Convert B to a sorted list (but the input is already given in sorted order, but maybe we should sort again to make sure? Probably not, since the problem states that the inputs are in ascending order.)

For each a in A:

   for each b in B:

      compute delta = (b - a) mod L.

      create a new list shifted_A = [(x + delta) % L for x in A]

      sort shifted_A.

      if shifted_A == B:

          print YES and exit.

So yes, this is manageable.

But wait, shifting each a in A by delta gives a list of elements, which when sorted should equal B. So the code would generate shifted_A, sort it, and compare to B.

But in the code, we need to generate shifted_A, sort it, and see if it matches B. Since B is already sorted, and shifted_A is sorted after sorting.

So for example, in the first sample input:

A = [2,4,6], B = [1,5,7].

Check all possible pairs:

Take a_i=2, b_j=1. delta = (1-2) mod8=7.

shifted_A becomes [2+7=9 mod8=1, 4+7=11 mod8=3, 6+7=13 mod8=5]. So shifted_A is [1,3,5], sorted becomes [1,3,5], which is not equal to B [1,5,7]. So this delta is not correct.

Wait, but the correct answer is YES, so where is the correct delta coming from?

Ah, perhaps the correct delta is 7.

Wait, in the sample input's note, the example shows that Sasha's list is [1,5,7]. So how does that fit with the actual barrier positions.

Original barrier positions (Kefa's) are 2,4,6. So when Sasha starts at position 7 (mod 8), the barriers' distances from her start are (2-7) mod8=3, (4-7) mod8=5, (6-7) mod8=7. So the distances are [3,5,7], sorted as [3,5,7], which is not the same as B's list [1,5,7]. So this seems conflicting.

Wait, this suggests that my understanding is incorrect. So what's wrong here?

Wait, perhaps the actual delta is (b_j - a_i) mod L, but when you shift the elements of A by delta, you subtract delta instead of adding. Let me re-examine the problem.

Earlier, I thought that (B_i - T) mod L is equal to (A_i - delta) mod L, where delta is T - S mod L.

So if delta is T - S mod L, then (B_i - T) mod L = (A_i - delta) mod L.

So rearranged, B_i mod L = (A_i - delta) + T mod L.

But the actual barrier positions in the track are S + A_i mod L. Also, T + B_i mod L. For these to be the same:

S + A_i ≡ T + B_j mod L.

For some j. So the set {S+A_i} must be equal to {T + B_j}.

So, rearranged, T = (S + A_i - B_j) mod L for some i, j.

But what's the delta between S and T?

delta = (T - S) mod L = (A_i - B_j) mod L.

So the shift between the two start points is delta = (A_i - B_j) mod L.

So the list B's elements must be (A_k - delta) mod L for each k.

So when we subtract delta from each A's elements, mod L, and sort, it should equal B's list.

Ah! So perhaps the correct approach is to compute delta as (a_i - b_j) mod L, then for each a in A, compute (a - delta) mod L, and check if that, when sorted, equals B.

In this case, for the first sample:

A is [2,4,6], B is [1,5,7].

Take a_i=2, b_j=1. delta is (2-1) mod8=1.

Then, subtract delta from each a in A:

2-1=1 mod8=1 → 1.

4-1=3 mod8=3 → 3.

6-1=5 mod8=5 →5.

So the shifted list is [1,3,5], sorted is [1,3,5], which is not equal to B [1,5,7]. So this delta isn't correct.

Take a_i=6, b_j=7. delta = (6-7) mod8= (-1) mod8=7.

Subtract delta from each a in A:

2-7 = -5 mod8=3.

4-7= -3 mod8=5.

6-7= -1 mod8=7.

So the list is [3,5,7], sorted is [3,5,7]. Not equal to B.

Hmm. So where is the correct delta?

Wait, perhaps I made a mistake in the direction of the shift. Let's think again.

If the actual barrier positions are S + a_i mod L. For Sasha's start T, the barrier positions must be T + b_j mod L. So S + a_i ≡ T + b_j mod L for all i, j.

But the problem states that the two lists must correspond to the same set of barriers. So the multiset { S +a_i mod L } must equal { T +b_j mod L }.

But how to relate this to the lists A and B.

Let me think of the sample input:

In the first sample, the barrier positions are 2,4,6 (since S is Kefa's start, which is considered 0). So when Sasha starts at position 7 (mod 8), her barriers would be (2-7) mod8=3, (4-7)=5 mod8=5, (6-7)=7 mod8=7. So the distances are 3,5,7, sorted as [3,5,7], which is not the same as B's list [1,5,7]. So this suggests that the sample explanation is different.

But according to the sample input, the answer is YES. So where's the mistake here?

Ah! Oh! Wait, the problem statement says that Kefa's and Sasha's tracks are considered the same if the positions of all barriers coincide, if they start running from the same points. So, the actual barrier positions must be the same. So Kefa's barrier positions are (0 + a_i) mod L. Sasha's barrier positions are (T + b_i) mod L. So the two sets must be the same.

So the problem is to check if there exists a T such that {a_1, a_2, ..., a_n} ≡ { (T + b_1) mod L, (T + b_2) mod L, ..., (T + b_n) mod L }.

Wait, no. Because Kefa's barrier positions are (S + a_i) mod L, and Sasha's are (T + b_i) mod L. But the actual track's barriers are fixed. So for the two tracks to be the same, the multiset { S + a_i mod L } must equal { T + b_i mod L }.

But S and T are the start points for Kefa and Sasha. So for the tracks to be the same, there exists some T such that the multiset { S + a_i } mod L equals { T + b_i } mod L.

But how to find T.

Rearranged:

T ≡ (S + a_i - b_j) mod L for some i,j.

But S is unknown. However, since S is arbitrary (because the track can be rotated to any start point), we can fix S as 0. So the barrier positions are a_1, a_2, ..., a_n. Then, for Sasha's track to have the same barriers, the multiset { T + b_i mod L } must equal { a_1, a_2, ..., a_n }.

So, T + b_i mod L must be in the set { a_1, ..., a_n } for all i.

But T can be any value, so we can compute T as (a_j - b_i) mod L for some j and i, then check if all (T + b_k) mod L are in the set A.

So the approach is:

- Generate all possible T candidates as (a_j - b_i) mod L for all a_j in A and b_i in B.

- For each candidate T:

   - For each b in B, compute (T + b) mod L.

   - Collect these values into a list, sort it, and check if it equals A sorted.

If any T satisfies this, output YES.

This is the correct approach.

Ah! Because the barrier positions for Kefa are A's elements (assuming S=0), and Sasha's barrier positions must be (T + b) mod L for each b in B. For the tracks to be the same, the set of these must be equal to A's set.

So this is the correct approach.

So in code:

Read n and L.

Read A list, sorted.

Read B list, sorted.

Convert A to a sorted list (which it is), and create a set for O(1) lookups.

For each a in A and each b in B:

   candidate_T = (a - b) mod L.

   create shifted_B = [ (candidate_T + b_j) % L for b_j in B ]

   sort shifted_B.

   if shifted_B == A:

       print YES and exit.

If none found, print NO.

So this is the correct approach.

In the first sample:

A is [2,4,6], B is [1,5,7].

Check all pairs a in A and b in B.

Take a=2, b=1. candidate_T is (2-1) mod8=1.

shifted_B becomes (1+1)=2 mod8=2, (1+5)=6 mod8=6, (1+7)=8 mod8=0. So shifted_B is [2,6,0]. Sorted, this is [0,2,6], which does not match A [2,4,6].

Next pair: a=2, b=5. candidate_T = (2-5) mod8 = (-3) mod8=5. shifted_B becomes (5+1)=6 mod8=6, (5+5)=10 mod8=2, (5+7)=12 mod8=4. So sorted shifted_B is [2,4,6], which matches A. So this candidate_T is 5, which is correct. So the answer is YES.

Ah! So this is the correct approach.

So the code should generate all possible T candidates as (a_i - b_j) mod L, then for each T, compute (T + b_j) mod L for each b in B, sort them, and check if it equals A.

Thus, the code is as follows.

So the code:

Read n and L.

Read list A, sorted.

Read list B, sorted.

Create a sorted_A and sorted_B (though input is already sorted).

For all a in A:

   for all b in B:

       T = (a - b) % L

       shifted_B = [ (T + x) % L for x in B ]

       shifted_B_sorted = sorted(shifted_B)

       if shifted_B_sorted == A:

           print("YES")

           exit()

After all pairs are checked, print("NO").

This is the correct approach.

Let's test this with the first sample:

A = [2,4,6], B = [1,5,7].

For a=2 and b=5: T = (2-5) mod8 = -3 mod8=5.

Then shifted_B is 5+1=6 mod8=6, 5+5=10 mod8=2, 5+7=12 mod8=4 → [6,2,4] → sorted is [2,4,6], which matches A. So yes.

So the code will find this pair and output YES.

Another example: the second sample input:

n=4, L=9.

A: [2,3,5,8]

B: [0,1,3,6]

We need to find a T such that (T + B) sorted equals A.

For example, take a=3 from A and b=0 from B.

T = (3-0) mod9=3.

Shifted_B: 3+0=3, 3+1=4, 3+3=6, 3+6=9 mod9=0 → [3,4,6,0], sorted is [0,3,4,6]. Not equal to A.

Take a=5 from A and b=3 from B:

T =5-3=2 mod9=2.

Shifted_B: 2+0=2, 2+1=3, 2+3=5, 2+6=8 → [2,3,5,8], which matches A. So this pair works.

Thus, the code will output YES.

The third sample input:

n=2, L=4.

A: [1,3]

B: [1,2]

Check all pairs.

For a=1, b=1: T=0. shifted_B is [0+1, 0+2] = [1,2] sorted. Doesn't match A [1,3].

For a=1 and b=2: T= (1-2) mod4= 3. shifted_B: (3+1=4 mod4=0, 3+2=5 mod4=1). So [0,1] sorted is [0,1] != [1,3].

For a=3 and b=1: T=3-1=2 mod4=2. shifted_B: 2+1=3 mod4=3, 2+2=4 mod4=0 → [3,0] sorted is [0,3] which equals A.

Wait, but A is [1,3]. So [0,3] sorted is [0,3] which is not equal to [1,3]. So this candidate does not work.

So code will print NO.

So this approach works.

So the code should correctly handle all cases.

Now, in terms of optimizations:

For the code, generating all possible pairs of a in A and b in B, which is up to 50 * 50 = 2500 iterations. For each iteration, we create a list of shifted_B, sort it, and compare to A. Since n is up to 50, sorting is O(50 log50) per iteration. So total time is acceptable.

In Python, even for the maximum input, this will be well within the time constraints.

Thus, the code is correct.
</think>

```python
n, L = map(int, input().split())
A = list(map(int, input().split()))
B = list(map(int, input().split()))

A_sorted = sorted(A)
B_sorted = sorted(B)

for a in A:
    for b in B:
        T = (a - b) % L
        shifted = [(T + x) % L for x in B_sorted]
        if sorted(shifted) == A_sorted:
            print("YES")
            exit()

print("NO")
```