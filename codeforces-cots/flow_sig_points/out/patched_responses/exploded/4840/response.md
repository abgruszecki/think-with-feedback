<think>
Okay, I need to solve this problem where I have to calculate the total traffic generated by the Send commands in a chat. Let's read the problem statement carefully.

So, the commands are Add, Remove, and Send. The Add and Remove commands don't generate traffic. But when a Send command is processed, each participant in the chat (including the sender) gets a message of length l, where l is the length of the message. So the total traffic for that Send is l multiplied by the number of current participants.

The goal is to compute the sum of all these traffic values for all Send commands.

Hmm. The input can have up to 100 commands, each line up to 100 characters. So the constraints are small, so even a straightforward approach should work. But since we need efficiency, let's think about the optimal way.

First, I need to keep track of the current participants in the chat. So probably a set data structure would be useful here. Because adding and removing elements from a set is O(1) average time, and checking existence is also O(1). Since the names are unique (due to the problem constraints that Add is only done if the person is not present, and Remove only if present), a set is sufficient.

For each Send command, we need to calculate the length of the message (the part after the colon), multiply by the current number of participants (the size of the set), and add this to the total traffic.

So the steps are:

1. Initialize a set to keep track of current participants.
2. Initialize a total traffic variable to 0.
3. For each line of input:
   a. If the line starts with '+', add the name to the set.
   b. If it starts with '-', remove the name from the set.
   c. Otherwise, it's a Send command. Split the line into sender_name and message_text. The message length is len(message_text). Multiply by the current size of the set and add to total.
   
Wait, but how do we parse the Send command? The format is <sender_name>:<message_text>. So we need to split the line into two parts, separated by the first colon. Because the sender name can't have a colon (since the problem states that the input is correct and the commands are formatted correctly). So splitting on the first colon is correct.

For example, in the line "Mike:hello", the sender is Mike and message is 'hello', length 5. If the message is empty, like "Mike:", then the message length is 0.

So for the Send command, the processing steps are:

- Split the line into sender and message parts. The split is on the first colon occurrence.
- The message length is the length of the message part. Even if the message is empty (like after the colon there's nothing), it's length 0.
- The number of participants is the size of the set. So multiply these two and add to total.

Now, handling the input. Each line is read as a command.

In Python, reading input lines can be done via input(). However, since there can be multiple lines, perhaps using a loop until EOF. But in programming competition problems, when input is from standard input, the code typically reads all lines until EOF. But in Python, if the input is given line by line, using a loop like:

import sys

for line in sys.stdin:
    line = line.strip()
    process(line)

But sometimes, for problems with multiple test cases, but in this problem, each test is a single input with up to 100 lines.

So in code:

We can read all lines using:

lines = [line.rstrip('\n') for line in sys.stdin]

But perhaps using a loop for each line:

But the problem says that each line is a command. So for each line in the input, process the command.

So code steps:

- Initialize a set, participants = set()
- total = 0

Then for each line:

if line starts with '+', then add the name (line[1:]) to the set.

if line starts with '-', then remove the name (line[1:]) from the set.

else: it's a Send command.

split the line into sender and message.

message_len = len(message)

count = len(participants)

total += message_len * count

So the key part is splitting the Send command correctly.

In Python, splitting on the first colon can be done using split(':', 1). For example:

parts = line.split(':', 1)
sender = parts[0]
message = parts[1] if len(parts) >1 else ''

So that even if there's no message (like "Mike:"), the message is considered as an empty string.

Yes. So the code for Send commands would be:

sender, message = line.split(':', 1)

Wait, but in Python, split with maxsplit=1. So for a line like "a:message", split into two parts. For "a:", split into ['a', ''].

So the split(':', 1) ensures that even if there are colons in the message, they are part of the message. But the problem says the input is correct, so the sender name is valid (doesn't contain colons), so the split will correctly separate the sender from the message.

So for the Send command processing:

parts = line.split(':', 1)
sender = parts[0]
message = parts[1] if len(parts) > 1 else ''
message_length = len(message)
count = len(participants)
total += message_length * count

Yes.

Now, code structure:

Read all lines.

Process each line:

For example:

Sample Input 1:

+Mike
Mike:hello
+Kate
+Dmitry
-Dmitry
Kate:hi
-Kate

Processing:

Participants starts empty.

Line 1: +Mike → add to set. Set size 1.

Line 2: Mike sends hello (length 5). Participants size is 1. So 5 * 1 =5. Total is 5.

Line3: +Kate → set size 2.

Line4: +Dmitry → size 3.

Line5: -Dmitry → size 2.

Line6: Kate sends 'hi' (length 2). Size is 2 → 2*2=4. Total 5+4=9.

Line7: -Kate → size 1.

No more lines. Output is 9. Which matches the sample.

So code is correct.

Edge Cases:

- Send command with empty message. Like "Mike:". Then message length is 0. So contributes 0.

- When the set is empty. But according to problem constraints, Send commands can only be processed if the sender is in the chat. Because the problem says that input is correct. So for example, if a Send command is given, the sender must be present (since Add and Remove are handled correctly). But the code will process the command regardless. Wait, but according to the problem statement, the input is guaranteed to be correct. So we don't need to handle invalid commands. So when processing a Send command, the sender is already in the set.

Wait, but according to the problem's input constraints, the input is correct. So when a Send command is processed, the sender is already in the chat. Because otherwise, the problem says that there are no such invalid cases.

So the code can safely process the Send command, because the sender is in the participants. So the code doesn't need to check if the sender is present. But in the code's logic, when processing a Send command, the sender is part of the participants. But the code counts all current participants, including the sender. So even if the sender is not present (which the problem says cannot happen), the code would process it. But since the input is correct, that case is not possible.

So code is okay.

Now, code in Python:

Read lines until EOF. For each line:

In Python, to read all lines, we can do:

import sys

participants = set()
total = 0

for line in sys.stdin:
    line = line.rstrip('\n')  # remove newline
    if not line:
        continue  # skip empty lines? But according to problem statement, each command is in its own line. So maybe no empty lines.
    if line[0] == '+':
        name = line[1:]
        participants.add(name)
    elif line[0] == '-':
        name = line[1:]
        participants.remove(name)
    else:
        # send command
        parts = line.split(':', 1)
        sender = parts[0]
        message = parts[1] if len(parts) > 1 else ''
        message_len = len(message)
        count = len(participants)
        total += message_len * count

print(total)

Testing this code against the sample input.

Sample 1:

Input lines:

+Mike
Mike:hello
+Kate
+Dmitry
-Dmitry
Kate:hi
-Kate

Processing:

After line1: participants {'Mike'}

Line2: split into Mike and hello → len 5. participants size 1 → 5*1 =5. total is 5.

Line3: add Kate → size 2.

Line4: add Dmitry → size3.

Line5: remove Dmitry → size2.

Line6: Kate:hi → split into Kate and hi → len2. size 2 → 2*2=4 → total 5+4=9.

Line7: remove Kate → size1.

Final total is 9. Correct.

Sample 2:

Input:

+Mike
-Mike
+Mike
Mike:Hi   I am here
-Mike
+Kate
-Kate

Processing:

Line1: add Mike. set size1.

Line2: remove Mike → set empty.

Line3: add Mike → size1.

Line4: send. message is 'Hi   I am here' → len is 13. size 1 → 13*1=13. total is 13.

Line5: remove Mike → empty.

Lines6 and7: add and remove Kate. No Send commands. So total is 13. But sample output is 14. Wait, wait sample 2's output is 14. Wait, what's the issue here.

Wait sample input 2's output is 14. Let's check:

The Send command is "Mike:Hi   I am here". Let's see the message text is 'Hi   I am here' → let's count the spaces.

"Hi   I am here" → H i followed by three spaces, then I, etc.

So the length is:

H (1), i (2), three spaces (5?), then I (6), space (7), a (8), m (9), space (10), h (11), e (12), r (13), e (14). Wait, let's count:

"Hi   I am here" → letters and spaces:

H i   I   a m   h e r e

Breaking down:

H i (space) (space) (space) I (space) a m (space) h e r e.

Wait the actual message is 'Hi   I am here' → let's count:

H i (2) followed by three spaces (5 total), then I (6), space (7), a (8), m (9), space (10), h (11), e (12), r (13), e (14). So total 14 characters.

So the length is 14. So the code would multiply 14 by 1 (since Mike is the only participant) → 14 added to total. So the sample output is 14. But according to the code:

In line4, message_len is 14, count is 1. So total becomes 14. Then other lines don't contribute. So why does the sample output 14?

Yes. So sample input 2's output is 14. So the code should output 14, which it does.

So the code is correct.

Another test case: Send command with empty message.

Input:

+Alice
Alice: 

Then message length is 0. So 0 added to total.

Now, code should handle that.

Yes.

Another edge case: a Send command with message that starts or ends with space. But according to the problem statement, the input data are correct, which implies that the message can't start or end with space. So the code doesn't need to handle that. So the input will not have such cases.

Thus, the code is correct.

So the code is as written.
</think>

```python
import sys

def main():
    participants = set()
    total = 0
    for line in sys.stdin:
        line = line.rstrip('\n')
        if not line:
            continue
        if line[0] == '+':
            participants.add(line[1:])
        elif line[0] == '-':
            participants.remove(line[1:])
        else:
            parts = line.split(':', 1)
            message = parts[1] if len(parts) > 1 else ''
            total += len(message) * len(participants)
    print(total)

if __name__ == "__main__":
    main()
```