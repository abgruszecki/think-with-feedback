<think>
Okay, let's tackle this problem. Hmm. The task is to calculate, for each message t from 1 to n, the number of distinct messages read when starting from t, following the links, and each time showing the k previous and next messages around the current one. And each time we process a message, we include the k messages before and after, but we have to count each message only once even if it's included multiple times.

The first thing I need to figure out is how to model the process efficiently. Because if I naively simulate each t from 1 to n and then for each step expand the visible messages and follow the links, that would be way too slow for n up to 1e5. So a brute-force approach is definitely out of the question. We need a smarter way.

Let's think about the structure here. Each message points to an earlier one. So the links form a DAG (directed acyclic graph) since each ai is less than i. That means there's no cycles in the links. So for any message, the chain of links will eventually terminate at 0 (or a message with no outgoing link).

The problem is that each time we jump to a link, we add a new visible range (k before and after the current message) to the set of read messages. The key is to model the union of all these ranges efficiently.

But how can we compute this union without actually expanding all the ranges each time?

Let's consider the ranges. For a message x, the visible range is [x - k, x + k], but clamped between 1 and n. For example, if k=0, then it's just x. When you follow a link to a previous message y, you then add the range [y -k, y +k], and so on.

But the order in which we process these ranges matters. Because once a message is included in the union, any subsequent ranges that include it don't add anything. So the total count is the size of the union of all ranges generated by following the chain of links.

So the question is, for each starting x, find the union of the ranges [x -k, x +k], [y -k, y +k], [z -k, z +k], etc., where x links to y, y links to z, etc., until there's no more links.

But how can we compute this efficiently for all x?

Hmm. Let's think in terms of dynamic programming. Suppose for a message x, once we process its link, we can reuse some precomputed information.

Wait, but the ranges could overlap. So for x, the visible range is [a, b], then when we jump to y, the visible range is [c, d], etc. The total is the union of all these intervals. The problem is that each interval can have varying start and end points.

One approach is to model the union of intervals as a merged interval. For example, if the current merged interval is [L, R], then adding a new interval [c, d] could potentially expand L and R. But this is only possible if the intervals can be merged into a single continuous interval. However, in some cases, the new interval [c, d] might be entirely within [L, R], or extend it on one side.

Wait, but the links are processed in order: first x's range, then y's (where y is a_x), then a_y, etc. So the ranges are added in a sequence. Each new range is for a message that is earlier than the previous (since the links go to lower-numbered messages). So the ranges are added in order from higher to lower positions.

But the merged intervals might not be contiguous. For example, if x is 10, k=2, then the range is 8-12. Then the next link is 5, which gives 3-7. The merged range would be 3-12. Then the next link might be 2, which gives 0 (clamped to 1) to 3. So merged becomes 1-12. Etc. So each step can potentially expand the merged interval.

Wait, but the merged intervals might not be contiguous. Wait, but when you process the ranges in order, the next range is for a lower-numbered message, but the ranges could be overlapping or not.

Alternatively, perhaps the merged interval after processing all links starting from x is simply the union of all ranges generated by following the chain. But how can we model this as a merged interval?

Wait, perhaps for a given x, the merged interval is [min_start, max_end], where min_start is the minimum of the left endpoints of all ranges in the chain, and max_end is the maximum of the right endpoints. Because all the ranges are added in a way that each new range is for a message that is earlier than the previous. So the left endpoint (y -k) of each subsequent range could be smaller than the previous min_start, but the right endpoint (y +k) could be smaller than the current max_end. Wait, no. Because each time you follow a link, the message is y, which is less than the current x. So the y's are decreasing. So the ranges for y could have higher or lower endpoints than previous ones.

But perhaps the overall merged interval is the minimum left and maximum right of all the ranges in the chain. Because that's the minimal interval that covers all the ranges. So for example, if the chain is x, a_x, a_{a_x}, etc., then the merged interval is [min(L_i), max(R_i)], where L_i and R_i are the left and right endpoints of each range.

If that's the case, then the size of the merged interval is max_end - min_start + 1, but clamped between 1 and n.

So for each x, the number of messages read is the number of distinct integers in the merged interval [min_start, max_end], which is max(0, max_end - min_start + 1). But wait, if the merged interval is [3, 10], then the count is 8 messages.

But this is only true if all the ranges are contiguous. For example, if we have ranges [1, 3] and [5, 7], the merged interval would have min_start 1 and max_end 7, but the actual count is 3 + 3 = 6. But that's not correct. So this approach would overcount. So that's a problem.

So the earlier idea that the merged interval is the min and max of all the ranges is only valid if the ranges are overlapping. Otherwise, the count would be higher.

Hmm. So this approach can't work. So how do we model the union of multiple ranges?

Alternatively, perhaps the way the links are followed ensures that the ranges are added in a way that each subsequent range's left endpoint is to the left of the previous merged interval. Because each link points to a message with a lower index. So for example, if you start at x, which has a range [x -k, x +k], then the next link is to y < x, whose range is [y -k, y +k]. Since y < x, and the next range's left endpoint is y -k, which could be less than the current min_start. But the right endpoint is y +k, which is less than x +k (since y < x). So the next range's right endpoint may be less than the current max_end. So the merged interval after processing x and y would be [min(x -k, y -k), max(x +k, y +k)]. But if the next step's link is to z < y, then z's range is [z -k, z +k]. So the merged interval's min_start could decrease, and the max_end could increase or stay the same.

Wait, but if z +k is larger than the previous max_end, then the merged interval's max_end increases. But since each z is a message with a lower index than the previous, z could be up to (max_end_prev -k) to have a range that extends to the right. Hmm. Not sure.

But this line of thinking suggests that the merged interval is indeed the min of all left endpoints and the max of all right endpoints. But in this case, the merged interval would cover all ranges. So the union of all ranges would be the interval from the earliest left to the latest right.

But that's only true if all the ranges are connected. Otherwise, gaps would exist.

But in the case of following links, the ranges may not be contiguous. For example, x=5, k=0: the range is [5,5]. Then link to y=3, which is [3,3]. Then link to 1, [1,1]. The merged ranges are [5], then [3,5], then [1,5]. So the merged interval would be [1,5], which has 5 elements. The actual union is {1,3,5}, which is 3 elements. But the approach of taking min and max would give 5 elements, which is wrong.

So this approach is incorrect. Thus, the initial idea is flawed. So we need a different approach.

Therefore, we need a way to compute the union of all the ranges generated by following the links, and find the total count. But how?

Alternative idea: For each message x, the process of following links forms a chain: x, a_x, a_{a_x}, etc. Each step in the chain adds the range [y -k, y +k] (clamped to 1 and n). The union of all these ranges is the set of all messages covered by any of these ranges.

But how can we compute this efficiently for all x?

Hmm. Let's think for each x, the set of ranges is [x0 -k, x0 +k], [x1 -k, x1 +k], ..., where x0 = x, x1 = a_x, etc., until a_x is 0.

The problem is to find the union of all these ranges. The size of this union is the answer for x.

But for n=1e5, processing each x separately is O(n) per x, which is O(n^2) time, which is way too slow.

So we need a way to compute this for all x in O(n) or O(n log n) time.

Alternative approach: For each x, the union of the ranges is determined by the ranges generated by the entire chain. Since each link points to a smaller index, the chain is finite (length at most x).

But again, processing each chain for each x is O(n^2) in the worst case.

Thus, we need to find a way to memoize or precompute some information that allows us to compute the answer for x quickly based on the answer for a_x.

Dynamic programming approach: For each x, when we process it, we can compute the merged interval as the combination of the current range and the merged interval of a_x.

Wait, maybe. Let's say when we follow x's link to a_x, the merged interval for x is the union of x's range and the merged interval of a_x. Because when you process x, you add its range, then proceed to a_x's range, which would have already computed the merged interval for a_x (since we process x in order from 1 to n).

Wait, but the links point to earlier messages, so for x, a_x is less than x. So if we process x in order from 1 to n, when we compute x's answer, a_x's answer (if any) is already computed.

Wait, but the answer for a_x is the number of messages in the union of all ranges starting from a_x. But when x follows a_x, the merged intervals for x's chain would include x's own range and a_x's ranges. So the merged interval for x's chain is the union of x's range and the merged interval of a_x's chain.

But how can the merged intervals be represented? Let's model for each x, the leftmost and rightmost indices covered when starting at x. Let's call these L[x] and R[x]. Then, when you process x, you compute L[x] as the minimum between the left of x's range and L[a_x], and R[x] as the maximum between the right of x's range and R[a_x]. Then, the answer for x is R[x] - L[x] + 1. But this is only correct if the ranges are connected, which may not be the case.

Wait, but in the example where x=5 (k=0), a_x=3 (k=0), a_3=1 (k=0), then L[x] would be 1, R[x] 5. But the actual union is {1,3,5}, size 3. But according to the formula, 5-1+1=5, which is wrong.

So this approach is incorrect.

So what's wrong here? The assumption that L and R can capture the merged interval's start and end. But when the ranges are not contiguous, this approach overcounts.

So another way: the merged interval for x's chain is the union of x's range and the merged interval of a_x's chain. But how to model this union?

Alternative idea: the merged interval for x is the union of x's range and the merged interval of a_x's merged interval. So if x's range is [l1, r1], and a_x's merged interval is [l2, r2], then the merged interval for x would be [min(l1, l2), max(r1, r2)] if these ranges overlap or are adjacent. But if they are disjoint, then the merged interval is the combination of both ranges, which would be two separate intervals. But storing that for each x would be impossible for n=1e5.

Hmm. So this approach isn't feasible. So how else can we model this?

Another thought: For each x, the answer is the union of all ranges generated by the chain starting at x. But if these ranges are connected, then the answer is simply the maximum R and minimum L of all ranges. But if they are not connected, then this method would overcount.

But perhaps, given the way the links are followed (each link is to a lower index), the ranges may form a contiguous block. Let's think: when you process x, which is higher than a_x, the next range is for a_x, which is a lower index. So x's range is [x -k, x +k], and the next is [a_x -k, a_x +k]. Since a_x is less than x, the next range's left end is a_x -k, which could be less than x -k. But the right end is a_x +k, which is less than x +k (since a_x < x). So the next range's right end is lower than x's right end. Thus, the ranges may or may not overlap.

But perhaps the merged interval for x is [min(L[x], a_x's L), max(R[x], a_x's R)].

Wait, for example, x=5, k=2: x's range is 3-7. Then a_x is 3, which has range 1-5. So the merged interval is 1-7. Then a_3 is 1, which has range 0 (clamped to 1) to 3. Merged becomes 1-7. So the answer is 7 messages. But the actual union is the ranges 3-7, 1-5, 1-3. The union is 1-7, which is 7 messages. So the formula works here.

Another example: x=5, k=0. x's range is 5. a_x is 3, which's range is 3. a_3 is 1. So ranges are 5,3,1. The merged interval is [1,5], which has 5 elements. But the actual count is 3. So the formula overcounts.

So the approach works when the ranges are overlapping but not when they are not. So this suggests that the approach is incorrect.

Hmm. So the problem is that when the ranges are not overlapping, the merged interval's size (max - min +1) is larger than the actual number of distinct messages.

Thus, we need a different way to model this.

Alternative approach: For each x, the answer is the sum of the ranges generated, minus overlaps. But calculating this is difficult.

Wait, but maybe the links are structured in a way that each step's range is included in the previous merged interval, so no new messages are added. Then the answer would just be the merged interval of the first step. But that's not the case.

Alternatively, perhaps once you follow a link to a message y, the range of y is already covered by the current merged interval. Then, processing the link adds nothing. But if the link's range is outside, then it adds new messages.

Wait, but how can we determine if the next link's range is already covered by the current merged interval?

So here's an idea: when processing x, the merged interval is [L, R]. Then, when you follow the link to a_x, which has its own merged interval [L', R'], if [L', R'] is within [L, R], then adding it doesn't change the merged interval. Otherwise, the merged interval becomes the union of [L, R] and [L', R'], which is [min(L, L'), max(R, R')].

But how do we model this?

Perhaps for each x, we can compute L[x] and R[x], which is the merged interval after processing x and all links. Then, when x's a_x is 0 (no link), L[x] and R[x] are just the range of x. Otherwise, if a_x's L and R are already within x's range, then L[x] and R[x] are x's range. Otherwise, if a_x's merged interval extends beyond x's range, then L[x] and R[x] are the min and max.

Wait, but how can we compute that?

Let's try to model it. For each x:

x's own range is [l, r], where l = max(1, x -k), r = min(n, x +k).

Then, if a_x is 0, then L[x] = l, R[x] = r.

Otherwise, when a_x is not 0, we look at the merged interval of a_x, which is [L_prev, R_prev]. Now, the merged interval for x's chain would be the union of [l, r] and [L_prev, R_prev].

The union of these two intervals is [min(l, L_prev), max(r, R_prev)].

But this is only true if the two intervals are connected. If they are not connected, then the union is two separate intervals, but in that case, the merged interval would still be the min and max, but the actual count would be (r - l +1) + (R_prev - L_prev +1) - overlap.

But since we are forced to model this with L[x] and R[x], perhaps the merged interval is the min and max, but the answer is the size of that interval.

But as the earlier example shows, this can be incorrect.

But perhaps, given the way the links are processed, the ranges are added in a way that the merged interval is indeed contiguous. Because each time you follow a link to a lower x, the range could be to the left of the previous merged interval, but perhaps overlapping with it.

Wait, let's take the example where x=5, k=0. So x's range is [5,5]. Then, a_x is 3, which's range is [3,3]. Then, a_3 is 1, range [1,1]. So the merged ranges are 5,3,1. The union is 3 distinct messages. But according to L and R, it would be min(5,3,1) =1, max(5,3,1) =5. So size 5, which is wrong.

So this approach is not correct.

Alternative idea: For each x, the answer is the union of x's range and the answer of a_x. But the answer for a_x is the set of messages covered by a_x's chain. So the answer for x is the size of the union of x's range and a_x's answer's messages.

But how can we model this? Storing the set of messages for each x is impossible for n=1e5.

Thus, we need a way to represent the union efficiently.

Another approach: For each x, the answer is the number of unique messages in x's own range plus the answer from a_x, minus the overlap between x's own range and the answer from a_x.

But how to compute the overlap?

Let's formalize this:

ans[x] = (number of messages in x's range) + ans[a_x] - overlap between x's range and ans[a_x]

But ans[a_x] is the number of messages covered by a_x's chain. The overlap is the number of messages in the intersection of x's range and a_x's merged interval.

But again, to compute this, we need to know the merged interval for a_x.

Wait, perhaps if we track for each x the merged interval [L, R], then ans[x] = max(R, R_prev) - min(L, L_prev) + 1. But this is the same as the previous approach. Which we know is incorrect.

Hmm. I'm stuck. Let's look for patterns in the sample inputs.

First sample input:

6 0

0 1 1 2 3 2

Output: 1 2 2 3 3 3

For x=6: the chain is 6 → 2 →1. Each step adds their own ranges (k=0, so each step adds exactly the current message). So the union is {6,2,1} → count 3. Which matches the output.

But according to the L and R approach, for x=6, L is min(6, 2, 1) =1, R is max(6, 2, 1) =6. So the size would be 6-1+1=6, which is wrong.

So the L and R approach is incorrect.

Another sample: second sample input, i=6, which output is 6.

The chain is 6 →5→4→3→2, but with k=1.

For each step:

Starting at 6 (k=1):

First, range is 5,6,7. Then, link to 5. The range for 5 is 4,5,6. Then link to 4: 3,4,5. Then link to 3: 2,3,4. Then link to 2: 1,2,3. Then link to 1: 0 (clamped to 1) and 2. So the ranges are [5-7], [4-6], [3-5], [2-4], [1-3]. The union of these is 1-7 → 7 messages. But the output is 6. Wait, the sample says the output is 6. Hmm, perhaps I made a mistake in the example.

Wait, let me recheck the second sample's note.

In sample two, i=6 gives output 6. The note says that the process is:

Start at 6: visible messages 5,6,7 (k=1). Then link to 5: visible messages 4,5,6. Then link to 4: messages 3,4,5. Then link to 3: messages 2,3,4. Then link to 2: messages 1,2,3. Then no link. So the union is 5-7, 4-6, 3-5, 2-4, 1-3. The union covers from 1 to 7. So that's 7 messages. But the output is 6. Oh, perhaps the sample input has n=10. Let me check the second sample:

Sample input 2:

10 1

0 1 0 3 4 5 2 3 7 0

So n=10. For x=6, the chain is 6 →5 →4 →3 →2 →1 (since a_6=5, a_5=4, a_4=3, a_3=2, a_2=1, a_1=0).

For each step:

x=6: [5,6,7] (since 6-1=5, 6+1=7, clamped to 10).

Then 5's range: 4-6.

Then 4's: 3-5.

Then 3's: 2-4.

Then 2's:1-3.

Then 1's:1-2 (since 1-1=0, clamped to 1, 1+1=2).

So the union of these ranges is:

5-7,4-6,3-5,2-4,1-3,1-2.

The union is from 1 to 7 → 7 messages. But the output says 6. Wait, what's the correct answer here? The note says that the answer is 6. Hmm, why?

Ah, the note says:

"In the second sample case i = 6 gives you messages 5,6,7 since k = 1, then 4,5,6, then 2,3,4 and then the link sequence breaks. The number of distinct messages here is equal to 6."

Wait, perhaps I made a mistake in the chain steps. Let me check the links again:

The input for sample 2 is:

0 1 0 3 4 5 2 3 7 0.

So a_1=0.

a_2=1.

a_3=0.

a_4=3.

a_5=4.

a_6=5.

a_7=2.

a_8=3.

a_9=7.

a_10=0.

So for x=6, a_6=5. a_5=4. a_4=3. a_3=0. So the chain is 6 →5 →4 →3. Then, since a_3 is 0, the process stops.

So the steps are:

x=6 → range 5-7 (messages 5,6,7).

Then a_6=5 → range 4-6 (messages 4,5,6).

Then a_5=4 → range 3-5 (messages 3,4,5).

Then a_4=3 → range 2-4 (messages 2,3,4).

Then a_3=0 → stop.

So the union of these ranges is 2-7, but wait:

5-7 (5,6,7) + 4-6 (4,5,6) → merged 4-7 (4,5,6,7). Then adding 3-5 (3,4,5). Merged becomes 3-7 (3,4,5,6,7). Then adding 2-4 (2,3,4). Merged becomes 2-7. So the count is 6 messages (2,3,4,5,6,7 → 6 elements). Because 7-2+1=6. Oh right! 2 to 7 is 6 elements (since 7-2+1=6). So the answer is 6. So the approach of taking the merged interval [L, R] as the min and max of all ranges would work here.

So in this case, the merged interval is [2,7], which has size 6.

But in the earlier example where the ranges are non-overlapping, the approach doesn't work.

Wait, why did it work in this case?

Because each subsequent range extends the merged interval to the left. So even though the ranges are not overlapping, the merged interval is a continuous block.

So maybe in this problem, the merged interval is indeed the min and max of all ranges. But why does it work here?

Because when you follow a link to a lower message, the new range may extend the merged interval's left end. The right end may not extend beyond the initial range. But since the ranges are processed in order from higher to lower, the left end may keep decreasing, and the right end may be the maximum of all ranges.

But in the case of non-overlapping ranges, like x=5 (k=0), a_x=3 (k=0), a_3=1 (k=0), the merged interval would be [1,5], but the actual count is 3. So the approach of using [min, max] would give 5, which is wrong.

So there's a contradiction here. Hence, the merged interval approach isn't sufficient.

Hmm. So how else can we model the problem?

Alternative idea: when following the chain of links, each new range can be added to the merged interval if it extends it either to the left or right. So for each x, we track the merged interval [L, R]. Then, when following the link to a_x, we check if a_x's merged interval extends L or R.

But how?

Perhaps the merged interval for x is:

L[x] = min(lx, L[a_x])

R[x] = max(rx, R[a_x])

But even if the a_x's merged interval is inside [lx, rx], we take the current L and R. Then the answer for x is R[x] - L[x] + 1.

But this would overcount in cases where the ranges are non-overlapping.

But why does this work in some cases?

In the second sample, for x=6:

lx = 5, rx=7.

L[a_x=5] is L[5]. Let's compute L and R for each node.

Let's compute L and R for the nodes in the sample:

Sample 2:

n=10, k=1.

The array a is [0,1,0,3,4,5,2,3,7,0].

Let's compute L and R for each x from 1 to 10:

x=1:

a_x=0. So L[1] = max(1-1,1) =0→1, rx=1+1=2. Clamped to 1-2.

So L[1]=1, R[1]=2. ans[1] = 2-1+1=2.

x=2:

a_x=1.

lx = 2-1=1, rx=2+1=3.

L[1] is 1, R[1] is 2.

So L[x] = min(1, 1) =1.

R[x] = max(3, 2) =3.

ans[x] =3-1+1=3.

x=3:

a_x=0.

lx=3-1=2, rx=3+1=4. Clamped.

So L[3]=2, R[3]=4. ans=3.

x=4:

a_x=3.

lx=4-1=3, rx=4+1=5.

L[3] is 2, R[3] is4.

So L[x] = min(3, 2) =2.

R[x] = max(5,4) =5.

ans=5-2+1=4.

x=5:

a_x=4.

lx=5-1=4, rx=5+1=6.

L[4] is 2, R[4] is5.

L[x] = min(4,2) =2.

R[x] = max(6,5) =6.

ans=6-2+1=5.

x=6:

a_x=5.

lx=6-1=5, rx=6+1=7.

L[5] is2, R[5] is6.

L[x] = min(5,2) =2.

R[x] = max(7,6) =7.

ans=7-2+1=6.

Which matches the sample output of 6.

x=7:

a_x=2.

lx=7-1=6, rx=7+1=8.

L[2] is1, R[2] is3.

So L[x] = min(6,1) =1.

R[x] = max(8,3) =8.

ans=8-1+1=8. But according to the sample output, x=7's answer is6. Wait, this contradicts the sample.

Sample output for x=7 is6, but according to this approach, it's 8.

Hmm. So this approach is invalid. Because according to the sample input, for x=7, the answer is6.

So why is this discrepancy?

Let's think about x=7.

a_7=2. So the chain is 7 →2 →1 →0.

The ranges are:

x=7:6-8 (assuming n=10, so 6,7,8.

a_x=2:1-3.

a_2=1:1-2.

So the merged ranges are 6-8, 1-3, 1-2.

The union is 1-3 and 6-8 → total 3+3=6 messages. So the answer is6. But according to the L and R approach, L=1, R=8, which would give 8-1+1=8, which is incorrect.

Thus, the approach is incorrect.

So this suggests that the merged interval approach is not sufficient. So what's the correct way?

Alternative approach: For each x, the answer is the size of the union of all ranges generated by following the chain starting at x. To compute this, we need to model for each x the leftmost and rightmost points covered, and also any "gaps" that are filled by subsequent ranges. But it's impossible to track this for each x.

Hmm. Let's think recursively. For x, the union is the range of x plus the union of the ranges from a_x's chain, but excluding any parts already covered by x's range.

Wait, but how can we model that?

Perhaps the answer for x is:

ans[x] = (size of x's range) + ans[a_x] - overlap between x's range and the merged interval of a_x's chain.

But to compute the overlap, we need to know the merged interval of a_x's chain. So if we track for each x the merged interval [L[x], R[x]], then the overlap is the intersection of x's range and [L[a_x], R[a_x]].

But how to compute the size of the intersection.

The overlap between [l1, r1] and [l2, r2] is max(0, min(r1, r2) - max(l1, l2) +1).

So the formula becomes:

ans[x] = (r - l + 1) + ans[a_x] - overlap.

But ans[a_x] is the size of the merged interval of a_x's chain, which is R[a_x] - L[a_x] +1. But this might not be correct because of overlapping ranges.

But in reality, ans[a_x] is the actual count of distinct messages in the merged intervals of a_x's chain. So this formula would be accurate only if the merged interval of a_x's chain is contiguous and overlaps with x's range.

But if the merged interval of a_x's chain is not contiguous, then this approach would also be incorrect.

But how can we model the actual count?

Alternative idea: For each x, the answer is the size of x's range plus the answer for a_x minus the overlap between x's range and the entire merged ranges of a_x's chain.

But since the merged ranges of a_x's chain may not be contiguous, how can we compute the overlap?

But perhaps the merged interval approach is the best we can do. Even though it's not always correct, perhaps in the problem's constraints, it's sufficient. Or perhaps the way the links are structured ensures that the merged interval approach is correct.

Wait, the links are such that each a_x < x. So the chain for x is x → a_x → a_{a_x} → ... →0. So each link is to a lower index. So when processing x's chain, the ranges are added in order of decreasing x. So the first range is x's, then a_x's (which is a lower index), then a_{a_x}'s (even lower), etc.

But how does this affect the merged ranges?

For example, x's range is [l, r], and the next range is [l', r'], which is for a lower index. Since a_x < x, l' = max(1, a_x -k) <= max(1, x-1 -k) (since a_x <x). So if k is large enough, the ranges could overlap.

But if k is small, the ranges may not overlap.

But the merged interval approach would take the min and max of all ranges, regardless of overlaps. But this leads to overcounting.

But perhaps in practice, the answer is R[x] - L[x] +1.

But in the sample where x=5, k=0, and the chain is 5→3→1, the merged interval is 1-5, so 5-1+1=5, but the actual answer is3.

So this approach is incorrect. So why does it work for some samples but not others?

Maybe the problem has some hidden constraints that allow this approach to work. Or perhaps the answer is not always R-L+1, but there's a way to compute it correctly using dynamic programming.

Alternatively, maybe there's another way to model the problem.

Wait, think about the direction of the links. Since each link points to an earlier message, the chain for x is x, a_x, a_{a_x}, etc. So the ranges are added in order from higher to lower. So each new range's start is lower than the previous one. But the end could be higher or lower.

But the ranges are added in a sequence. The first range is for x, then a_x, then a_{a_x}, etc. Each new range is for a lower index. So for example, x's range is [x-k, x+k], next is [a_x -k, a_x +k], which is to the left of x (since a_x <x). So perhaps the ranges are added in a way that their starts are in decreasing order. So the merged interval is determined by the earliest start and the latest end.

But how does this affect the union of the ranges?

For example, x=5, a_x=3, a_3=1.

x's range: [5-0=5,5+0=5] → [5,5].

a_x's range: [3,3].

a_3's range: [1,1].

The merged interval is [1,5], which includes 5,3,1. But the actual union is 3 elements.

But according to the approach, the answer is5.

So this is wrong.

Hmm. So this approach is not correct.

Alternative idea: When following the links, the new range is added to the merged interval. But if the new range is entirely contained within the current merged interval, then it doesn't contribute any new messages. Otherwise, the merged interval is extended.

So, for each x, when processing a_x's merged interval:

new_L = min(current_L, a_x_L)

new_R = max(current_R, a_x_R)

If the new_L and new_R are the same as current_L and current_R, then a_x's chain doesn't contribute any new messages. Otherwise, we take the new merged interval and proceed.

But how to model this.

So for x's chain:

merged_L = x's l

merged_R = x's r

then, for each link in the chain (y = a_x, z = a_y, etc.):

y_l = max(1, y -k)

y_r = min(n, y +k)

if y_l < merged_L:

   merged_L = y_l

   merged_R = max(merged_R, y_r)

elif y_r > merged_R:

   merged_R = y_r

else:

   no change.

But this is assuming that the new range only extends the merged interval either to the left or the right. If the new range is to the left of merged_L, then merged_L is updated, and merged_R could be increased. If the new range is to the right of merged_R, then merged_R is updated. Otherwise, if the new range is entirely within merged_L and merged_R, then no change. But if the new range is partially overlapping, then merged_R and merged_L are adjusted.

But this approach may not capture all possible overlapping cases.

For example, let's say merged_L is 5, merged_R is 10. The new range is [3, 8]. The new merged_L would be 3, merged_R would remain 10. So the merged interval becomes [3,10], which includes all the new messages. The actual union is 3-10, which is correct.

Another example: merged is [5,10]. new range is [7,12]. merged_R becomes 12. merged_L is 5.

Another example: merged is [5,10]. new range is [2,3]. merged_L becomes 2. merged_R remains 10.

But what if the new range is [4,7] which is partially overlapping. Then merged_L becomes 4, merged_R 10.

But the actual union is 4-10. But according to the model, it's correct.

But what if the new range is [6, 8], which is entirely within merged [5,10]. Then no change.

Thus, this approach captures the merged interval correctly, assuming that each new range is processed in a way that extends the merged interval either to the left or right, and ignores ranges that are fully contained within the current merged interval.

But how does this model handle the case where the new range is not overlapping with the current merged interval but is added to the left?

For example, merged is [5,10]. new range is [1,3]. merged_L becomes 1, merged_R remains 10. So the merged interval is [1,10], which is correct. But the actual union is 1-10, which includes all messages from 1 to10. The size is 10. But according to the model, it's correct.

But what if the new range is [1,2], and merged is [4,5]. Then the merged interval becomes [1,5], which is correct.

But what if the new range is [3,4], which is between the merged [1,2] and [4,5]. The merged interval becomes [1,5], which is correct.

So this model seems to capture the merged interval correctly.

But what about the case where the new range is non-overlapping and to the right of the current merged interval?

For example, merged is [1,3], new range is [5,7]. According to the model, since new range's start (5) is greater than merged_R (3), merged_R is updated to 7. The merged interval is [1,7], which includes 7-1+1=7 messages, but the actual union is [1-3] and [5-7], which is 3 +3=6 messages. So the model overcounts.

Ah, here's a problem. So this model is only accurate when the ranges are overlapping or adjacent. If there's a gap between the merged interval and the new range, the model will count the entire merged interval as the min and max, which includes the gap, leading to an overcount.

But in the problem, the new range comes from a link to a lower message, which is processed after the current merged interval. So the new range is for a message with a lower index, so its start is less than the current merged interval's start. So when following a link, the new range is for a message lower than the current x, so its range could be to the left of the current merged interval.

So in the chain, the ranges are added in order of decreasing x. So each new range's start is less than or equal to the previous merged interval's start.

Thus, in the model, when processing a new range from a link, the new range's start is to the left of the current merged interval. So the model would merge the new range into the current merged interval by expanding the left side. But the new range's right side could be less than the current merged interval's right side. So the merged interval's right side may not change.

But this would mean that any new ranges added are to the left of the current merged interval. So the merged interval's left side may decrease, but the right side is the maximum between the current merged interval's right and the new range's right.

But this approach can lead to merged intervals that include gaps. For example:

current merged interval is [5, 10].

new range is [3,4], which is to the left of the current merged interval. The new merged interval is [3,10]. The size is 8, but the actual union is 3-4 and 5-10, which is 4-10 (4-10 is 7 messages) plus 3-4 (2 messages), but overlapping at 4. So the actual union is 3-10 → 8 messages. So the model is correct here.

Another example: current merged interval is [5,10], new range is [1,2]. merged becomes [1,10]. The union is 1-10, which is 10 messages. Correct.

Another example: current merged interval is [5,10], new range is [3, 7]. merged becomes [3,10]. Correct.

So in all these cases, the model correctly captures the merged interval.

But the problem is when the new range is to the left of the current merged interval, and its right side is less than the current merged interval's left.

For example: current merged interval is [5,10], new range is [1,3]. merged becomes [1,10], but the union is 1-3 and5-10. Which has (3-1+1) + (10-5+1) =3 +6=9 messages, but according to the model, it's 10-1+1=10. So the model overcounts by 1.

In this case, the merged interval is [1,10], but the actual union is [1-3] and [5-10], which is 3+6=9. So the model is wrong here.

But according to the problem's sample input 2, the model works. So why?

Because in the problem's chain, the new ranges are added in a way that they overlap with the previous merged interval. For example, in sample 2:

x=6's merged interval is [5,7].

Then the next range is [4,6] (from a_x=5). The new merged interval is [4,7]. Which overlaps with [5,7].

Then next range is [3,5] (from a_x=4). Merged becomes [3,7]. Overlapping.

Then [2,4] (from a_x=3). Merged becomes [2,7].

So in each step, the new range's right side is within the previous merged interval's right. So the model works.

But if the new ranges are not overlapping, the model fails.

But the problem's links are such that each a_x is less than x, so the new ranges are for lower x's. Thus, the new ranges are to the left of the current x. So when we process x's merged interval, which starts at [x-k, x+k], then the next ranges are to the left. So their right sides are x's a_x +k. Since a_x <x, a_x +k can be up to x-1 +k. So if k is sufficiently large, the new range's right side may overlap with the current merged interval's left side.

For example, if x=5, k=2, then x's range is [3,7]. Then a_x=3's range is [1,5]. The merged interval becomes [1,7]. The new range's right side is5, which is less than the current merged interval's right (7). So the merged interval is [1,7].

In this case, the model works.

But if a_x's range is [1,3], and x's merged interval is [5,7], then merging gives [1,7]. But the actual union is 1-3 and5-7, which is6 messages. The model would give7-1+1=7. Which is wrong.

But how can this scenario happen?

For example, x=5, k=0. a_x=3, which is k=0. So x's range is [5,5]. a_x's range is [3,3]. The merged interval is [3,5]. The model gives5-3+1=3, which is correct.

Wait, in this case, yes. So model works here.

But earlier example where x=5, a_x=3, a_3=1 (k=0):

x's range is [5,5]. merged_L=5, merged_R=5.

Then a_x=3: range [3,3]. merged_L=3, merged_R=5.

Then a_3=1: range [1,1]. merged_L=1, merged_R=5.

The model gives 5-1+1=5, but the correct answer is3.

Ah, here's the problem. Because the merged interval includes all the messages between 1 and5, but in reality, only 1,3,5 are included. But according to the model, the answer is5, but correct is3.

So this is a case where the model fails.

But according to the problem's constraints, how can this scenario exist?

The problem allows k=0, which is the first sample.

So how can we handle this case?

This suggests that the model is incorrect and the approach would fail for some test cases.

But why does it work for the sample inputs?

Because in the first sample, the merged intervals are contiguous, but in this new example, the merged interval includes gaps that are not covered by any ranges.

Thus, the model is not sufficient.

So we need a different approach.

Alternative idea: For each x, the answer is the size of the union of the ranges generated by the chain starting at x. We can model this by precomputing for each x the leftmost and rightmost positions that are covered, and also the positions covered in between. But this is not feasible for large n.

Alternatively, think of the problem as a graph traversal, where each node is a message, and we have to compute the union of ranges for all nodes visited along the chain. But this is again O(n^2) in the worst case.

Wait, but the links form a tree-like structure. Each message x has a single parent a_x. So this is a forest of trees, where each node's parent is a_x.

So the chain for x is the path from x to the root (a_x =0).

Thus, the chain for x is x → a_x → a_{a_x} → ... →0.

So for each x, the chain is a path in this tree.

Now, if we can precompute for each x the union of all ranges along this path, then we can compute the answer for x.

But how?

Maybe we can use memoization. For each x, the union of ranges is the union of x's range and the union of ranges of a_x's chain.

But the union of ranges is the same as the union of x's range and the union of a_x's ranges. So if we can represent the union as a set of intervals, and merge them efficiently, we can compute this.

But for large n, this is impossible.

Thus, we need a way to represent the union of ranges for each x in a way that allows us to compute it quickly.

Alternative idea: Since the ranges are added in order of decreasing x, and each new range is to the left of the previous merged interval, perhaps the merged interval for x is the leftmost and rightmost of all ranges in the chain. But the actual count is the merged interval's size minus any gaps that are not covered by any of the ranges.

But how to track this?

Alternatively, if each new range extends the merged interval to the left, and the right is the maximum of all ranges' rights, then the merged interval for x is [L, R], where L is the minimum left of all ranges in the chain, and R is the maximum right.

But this gives us an overcount when there are gaps between ranges.

But how often does this happen?

In the first sample, the model works. In the second sample, it works. In the example where ranges are non-overlapping, it fails.

But given the problem's constraints and the sample inputs, perhaps the model is correct and the test cases are designed to allow this approach.

Alternatively, perhaps the problem's model requires us to compute the merged interval as [L, R], and the answer is R-L+1.

But this contradicts some examples.

Hmm. So perhaps the correct approach is to use this model, but why does it work for the samples?

In the first sample, for x=6:

ranges are6,2,1 (k=0).

 merged interval is [1,6], size 6-1+1=6. But the correct answer is3.

So the model gives6, but sample output is3.

But the sample's output for x=6 is3. So this model is not correct.

This suggests that the model is incorrect, and we need to find another approach.

Alternative Idea:

The key insight is that each time you follow a link, you jump to a message that is earlier. So the ranges you add are for lower and lower messages. So the ranges are added in order from higher to lower.

So the merged interval's left can only decrease, and the right can only increase or stay the same.

But how to compute the correct count of messages in the merged ranges.

Perhaps the merged ranges are contiguous. Because each new range is for a message that is lower than the previous, so the new range's left is lower than the current merged interval's left, and the new range's right is higher than the current merged interval's left.

But this is not necessarily the case.

Alternative Idea:

For each x, when processing the chain, the merged ranges can be represented as a single interval [L, R], which is the minimal interval containing all ranges in the chain. The count is R-L+1. But this overcounts when there are gaps.

But perhaps in this problem, the links are chosen in a way that the ranges overlap. But this is not guaranteed.

So this approach is not correct.

Hmm. I'm stuck. Let's think differently. Let's try to find a way to compute the answer for each x using dynamic programming.

Let's define for each x:

- l[x] = max(1, x -k)

- r[x] = min(n, x +k)

- The merged interval for x is [L[x], R[x]]

- The answer for x is the number of messages covered by the merged interval.

But how to compute L[x] and R[x].

When x has no link (a_x=0), then L[x] = l[x], R[x] = r[x], ans[x] = r[x] - l[x] +1.

When x has a link to y = a_x:

The merged interval for x is the union of [l[x], r[x]] and the merged interval for y.

But the merged interval for y is [L[y], R[y]].

So the merged interval for x is [min(l[x], L[y]), max(r[x], R[y])].

Thus, L[x] = min(l[x], L[y]), R[x] = max(r[x], R[y]).

The answer is R[x] - L[x] +1.

But this is the same as the initial approach, which is incorrect in some cases.

But according to the first sample, this approach gives the wrong answer.

Sample 1:

n=6, k=0.

a = [0,1,1,2,3,2].

For x=6:

l[x] =6, r[x]=6.

y = a_x=2.

L[y] = L[2], R[y] = R[2].

Compute L[2]:

For x=2, a_x=1.

l[2] =2, r=2.

y=1, a_1=0.

L[1] =1, R[1] =1.

Thus, L[2] = min(2, 1) =1. R[2] = max(2, 1) =2. ans=2-1+1=2.

So for x=6:

L[x] = min(6, 1) =1. R[x] = max(6, 2) =6. ans=6-1+1=6. But the correct answer is3.

Thus, this approach is invalid.

But why does this approach work for the second sample?

In the second sample, for x=7, the approach gives ans=8, but the correct answer is6. So the model is incorrect.

Hmm. So what's the correct way to model this?

Alternative Idea: The problem requires the actual count of distinct messages in the union of all ranges. To compute this, we can precompute for each x the set of messages in the union. But with n up to 1e5, this is impossible.

Another Idea: For each x, the messages in the union are exactly those covered by any of the ranges in the chain. So the count is the number of unique messages in the ranges of x, a_x, a_{a_x}, etc.

But how to compute this efficiently.

We can model the merged interval as the [L, R] and also track the number of messages added beyond the merged interval. But this seems difficult.

Alternatively, we can note that the union of the ranges is the interval from the earliest start to the latest end, minus any gaps that are not covered by any of the ranges.

But how to compute this.

Alternatively, perhaps the answer is indeed the merged interval's size, but the problem's test cases are designed to allow this approach. But the first sample contradicts this.

But in the first sample, the model gives 6-1+1=6 for x=6, but the correct answer is3.

So this approach is invalid.

Hmm. This problem is tricky. Let's think of another approach.

Each time you visit a message in the chain, you add its range. But each new range is for a message with a lower index. So the ranges are added in order of decreasing x.

So the earliest message in the chain is x, then a_x, then a_{a_x}, etc.

Each new range is for a message with a lower index than the previous.

Thus, the ranges are added from higher to lower.

But how to compute the union of all these ranges.

Another Idea: The union of the ranges is the interval from the earliest start (minimum of all ranges' starts) to the latest end (maximum of all ranges' ends). But the number of messages in this interval is the maximum end - minimum start + 1. But this is only correct if the ranges cover all messages in this interval. But this is not guaranteed.

But perhaps the way the links are structured ensures that this interval is fully covered by the ranges.

But how?

For example, if the ranges are added in order of decreasing x, and each new range's start is lower than the previous merged interval's start, but its end is higher than or equal to the previous merged interval's start.

But this is not necessarily the case.

Thus, the answer is not the size of the merged interval, but the number of messages in the union of all ranges.

But how to compute this.

Alternative Idea: We can model the merged interval as the earliest start and the latest end, and also track the number of messages added by each step.

But this would require knowing the merged interval and the count.

But the merged interval and the count are related, but not directly. For example, merged interval [1,5] could have 5 messages if all are covered, or fewer if there are gaps.

But again, how to model this.

Another Idea: For each x, the merged interval is [L[x], R[x]], and the count is the same as R[x] - L[x] + 1. But how to adjust this when new ranges are added.

This approach works if the merged interval is fully covered by the ranges in the chain.

But how to ensure that.

Alternatively, when a new range is added that is to the left of the current merged interval, but its right end is less than the current merged interval's left, then the new merged interval is the union of the two ranges, but this creates a gap between the new range's right and the current merged interval's left.

But how to track this.

Alternatively, perhaps the problem is designed in such a way that the merged interval is contiguous and covers all messages between L[x] and R[x]. Thus, the answer is R[x] - L[x] +1.

But this is not the case for all examples.

Hmm. Given the time constraints, perhaps the correct approach is to proceed with the dynamic programming approach, even though it's incorrect in some cases, and see if it passes the sample inputs and see where it fails.

But according to the first sample, this approach would give the wrong answer.

Sample 1:

n=6, k=0.

For x=6:

L[6] = min(6, L[2]).

L[2] = min(2, L[1]).

L[1] =1.

So L[6] =1.

R[6] = max(6, R[2]).

R[2] = max(2, R[1])= max(2,1)=2.

So R[6]=6.

ans=6-1+1=6. But sample output is3.

Thus, this approach is invalid.

Thus, this approach is not correct.

Hmm. So the problem requires a different approach.

Alternative Idea: Since each new range is added to the left of the previous merged interval, perhaps the merged interval is the union of the current merged interval and the new range's start up to the new merged interval's end.

Wait, but this is the same as the dynamic programming approach.

Hmm. Perhaps the correct approach is to realize that the merged interval is indeed the correct answer for the problem. But then why does the sample not match?

In the first sample, according to the model, the answer for x=6 is6, but the sample output is3. So the model is wrong.

So what's the correct way?

Perhaps the key is that when you jump to a link, you only include the visible messages of that link, but you don't include any previous messages from other ranges unless they are part of the new visible range.

But this is not the case. The problem statement says that each time you follow a link, you add the visible messages of the current message. So the initial step is to include the visible messages of the starting message. Then, follow the link, add the visible messages of that message, and so on.

But each addition is the union of all ranges. So the problem is to compute the union of all these ranges.

But how to compute this union efficiently.

An alternative approach is to note that the union of all ranges in the chain is the same as the union of all ranges generated by the messages in the chain. So for each x, the union is the union of ranges [l_i, r_i] where l_i = max(1, x_i -k) and r_i = min(n, x_i +k), where x_i is the message in the chain starting at x.

So the problem reduces to finding the union of all these intervals for the chain of x.

But to compute this for all x efficiently.

An alternative Idea: The union of the intervals can be represented as [min_l, max_r], but this is only correct if the intervals form a single contiguous block. Otherwise, it's wrong.

But the chain is processed in order of decreasing x_i. So the new intervals are added to the left of the current merged interval. So each new interval's start is less than the previous merged interval's start. The end of the new interval can vary.

Thus, the merged interval is the minimum of all starts and the maximum of all ends. But the actual count is the number of integers in this interval, which may overcount.

But in the first sample, this approach gives a wrong answer. So the correct answer must be computed differently.

Hmm. What's the correct way to compute the union.

Let's think about the first sample:

Sample 1:

n=6, k=0.

a = [0,1,1,2,3,2].

For x=6, chain is6→2→1.

Ranges are [6], [2], [1].

The union is {1,2,6} → count3.

The merged interval is [1,6], which has6 elements. So the model's answer is6, but the correct is3.

Thus, the model is incorrect.

So how to model this?

The correct way is to track all the ranges, but this is impossible for large n.

Alternative Idea: For each x, the answer is the size of the union of the ranges from x's chain. This can be computed as the sum of the lengths of the ranges minus the overlaps between each range and the ranges that come after it.

But how to compute this.

Alternatively, the union can be represented as the union of the ranges from x and all ranges from a_x's chain that are not already covered by x's range.

But how to compute this.

For example, for x:

ans[x] = size of x's range + ans[a_x] - overlap between x's range and the merged interval of a_x's chain.

The merged interval of a_x's chain is [L[a_x], R[a_x]]. The overlap is the number of integers in the intersection of x's range and [L[a_x], R[a_x]].

But the merged interval of a_x's chain is [L[a_x], R[a_x]], and ans[a_x] = R[a_x] - L[a_x] +1.

But the actual count for a_x's chain is ans[a_x], which may be less than R[a_x] - L[a_x] +1 if there are gaps.

Thus, this approach is incorrect.

Another Idea: For each x, the answer is ans[x] = size of x's range + ans[a_x] - the number of messages in x's range that are already covered by the ranges in a_x's chain.

But how to compute the number of messages in x's range covered by a_x's chain.

This requires knowing the merged interval of a_x's chain and the overlap between x's range and that merged interval.

But again, if the merged interval of a_x's chain is [L, R], then the overlap is max(0, min(rx, R) - max(lx, L) +1).

So:

ans[x] = (rx - lx +1) + ans[a_x] - overlap.

But this depends on ans[a_x] being the actual count of a_x's chain.

But ans[a_x] is R[a_x] - L[a_x] +1 minus the gaps in a_x's chain.

Thus, this approach may not work.

But perhaps in this way, the ans[x] can be computed correctly.

Let's try this with the first sample:

For x=6:

lx =6, rx=6.

ans[a_x=2] = ans[2] = 2.

 overlap is max(0, min(6, R[2]) - max(6, L[2]) +1).

 R[2] is computed as max(2, R[1])=2. L[2] is min(2, L[1])=1.

 So R[2] is 2, L[2] is1.

 overlap is max(0, min(6, 2) - max(6, 1) +1) → min is2, max is6. 2-6+1= -3 → overlap 0.

So ans[x=6] = 1 + 2 -0 =3. Which is correct.

Yes! So this approach seems to work.

Let's see for x=2:

a_x=1.

lx=2, rx=2.

ans[1] =1.

 overlap between [2,2] and L[1], R[1]=1-2.

 overlap is 0.

ans[2] =1 +1 -0=2.

Which matches the sample.

For x=1:

ans[x=1] = 2-1+1=2. But according to this approach:

ans[1] = (1,2) → size 2. Since a_x=0, no subtraction.

Yes.

So this approach seems to work.

Another test case:

x=5, k=0, a_x=3, a_3=1.

For x=5:

ans[5] = (5-5+1) + ans[3] - overlap.

ans[3] is (3-3+1) + ans[0] - overlap.

ans[3] = 1 +0 -0=1.

overlap between x=5's range (5-5) and a_x=3's merged interval [3's range is [3-3], and ans[3] is1. But according to the new approach:

For x=3:

ans[3] = (3-3+1) + ans[0] - overlap. ans[0] is0. So ans[3] =1.

L[3] =3-0=3, R[3]=3+0=3.

For x=5's overlap: x's range is5-5. a_x's merged interval is [3-3]. overlap is0.

ans[5] =1 +1 -0=2.

Then x=5's a_x=3, which's a_x=0.

Then x=3's ans is1.

ans[5] is2.

But the actual union is5,3,1 → count3.

So this approach gives ans[x=5] =1 +1 -0=2. Which is incorrect.

So this approach is also incorrect.

Hmm. So why does it work for the first sample but not for this case?

In this case, the merged interval for x=3 is [3,3], ans=1.

The merged interval for x=5 is [5,5], ans=1 + ans[3] - overlap.

 overlap between [5,5] and [3,3] is0. So ans=1+1-0=2.

But the correct answer is3.

So the approach is still incorrect.

Thus, this suggests that the problem requires a different approach.

Another Idea: The correct way to compute the answer is to track the merged interval [L, R] and also track the actual count of messages covered. For each x, when processing a_x's chain, we can compute the new merged interval and the count as the previous count plus the new range's contribution minus the overlap.

But how to track the count and merged interval.

Let's define for each x:

- merged interval [L[x], R[x]].

- count[x] is the number of messages in the union of all ranges in x's chain.

Then, for x with a_x=0:

L[x] = lx

R[x] = rx

count[x] = rx - lx +1.

For x with a_x= y:

The merged interval is [min(lx, L[y]), max(rx, R[y])].

The new count is count[y] + (rx - lx +1) - overlap between x's range and the merged interval of y.

 overlap is max(0, min(rx, R[y]) - max(lx, L[y]) +1).

 count[x] = (rx - lx +1) + count[y] - overlap.

But let's test this for x=6 in sample1.

x=6's a_x=2.

y=2.

For x=6:

lx=6, rx=6. range is [6,6].

y's merged interval is [1,2], count[y] is2.

overlap between [6,6] and [1,2] is0.

count[x] =1 +2 -0=3. Which is correct.

For x=5 in the example where a_x=3, a_3=1:

x=5:

lx=5, rx=5.

y=3's merged interval is [3,3], count[y]=1.

overlap between [5,5] and [3,3] is0.

count[x] =1 +1-0=2.

But the correct answer is3.

So this approach is still incorrect.

So why?

Because the merged interval for x's chain is [3,5], but count[x] is2, which is the sum of x's range (1) and y's count (1), minus overlap (0). But the actual count is3.

Thus, this approach is also incorrect.

Hmm. What's the correct way to compute the count?

The correct count for x=5's chain is the union of x's range and y's chain's ranges. So:

x's range:5.

y's chain's ranges:3,1.

 union is5,3,1 → count3.

But according to the approach, count[x] =1 + count[y] (which is2) - overlap (0) →3.

But according to the previous test case, count[y] for y=3 would be2. How?

Let's compute for x=3:

a_x=1.

y=1's merged interval [1,2], count[y] is2.

overlap between [3,3] and [1,2] is0.

count[x=3] =1 (size of x's range) +2 -0=3.

But the actual count for x=3's chain is3: ranges [3], [1].

Union is3 and1 → count2.

But according to this approach, it's3.

Thus, the approach is incorrect.

So this approach is not working.

Hmm. I'm stuck. Perhaps the correct way is to use a memoization approach to track the merged interval and the actual count.

But for large n, this would be O(n) time, which is acceptable.

But how to implement this.

Let's think recursively.

For each x:

if x has been processed, return [L, R, count].

else:

compute lx = max(1, x-k), rx = min(n, x +k).

if a_x ==0:

   L = lx, R = rx, count = rx - lx +1.

else:

   recursively process a_x to get [L1, R1, cnt1].

   merged_L = min(lx, L1).

   merged_R = max(rx, R1).

   overlap = max(0, min(rx, R1) - max(lx, L1) +1).

   merged_count = (rx - lx +1) + cnt1 - overlap.

   L = merged_L

   R = merged_R

   count = merged_count.

So for each x, we compute the merged interval and the count.

Let's test this for the first sample.

Sample1:

x=6:

a_x=2.

Process x=2:

a_x=1.

Process x=1:

a_x=0.

L=1, R=2-1+1=2. count=2.

x=2:

lx=2, rx=2.

process a_x=1 → [1,2, 2].

overlap between [2,2] and [1,2] is1 (since min(2,2)=2, max(2,1)=2 → 2-2+1=1).

merged_count = 1 +2 -1=2.

L=1, R=2.

x=6:

lx=6, rx=6.

process a_x=2 → [1,2,2].

overlap between [6,6] and [1,2] is0.

merged_count=1 +2-0=3.

L=1, R=6.

So count=3. Correct.

For x=3 in the earlier example:

a_x=1.

process x=1:

count=2.

x=3:

lx=3, rx=3.

a_x=1.

overlap between [3,3] and [1,2] is0.

merged_count=1 +2 -0=3.

L=1, R=3.

So count=3. But the actual union is3 and1 → count2.

Thus, this approach overcounts.

So what's the issue?

The overlap is computed based on the merged interval of a_x's chain, not the actual overlapping messages.

In this example, the merged interval of a_x's chain is [1,2], count=2. But the overlap between x's range [3,3] and a_x's merged interval is0. So the count is1+2=3.

But the actual union is3,1, which is2.

So the approach is incorrect.

The problem is that the merged interval of a_x's chain is [1,2], count=2. But the actual union of a_x's ranges is [1,2] (but the count is 2). So the approach is correct for a_x's chain, but when x's range is added, the merged_count is computed as the sum of the ranges minus their overlap.

But in this case, there's no overlap, so the merged_count is3, but the actual count is2.

But according to the model, the merged interval is [1,3], count3.

But the actual merged ranges are [1,2] and [3,3], which are contiguous. So the merged interval is [1,3], count3. Which is correct.

Wait, but the union of [1,2] and [3,3] is 1,2,3 →3 elements. So the model is correct.

But in this case, the correct count is3, not2.

But the example I thought of earlier where x=3's chain is3→1:

The ranges are [3,3], then [1,1]. The union is3,1 →2 elements.

But according to the model:

x=1 has a_x=0. count=1 (range [1,1]).

x=3's a_x=1.

merged_L = min(3-0=3, 1) =1.

 merged_R = max(3, 1) =3.

 overlap = max(0, min(3,1) - max(3,1) +1) → min(3,1)=1, max(3,1)=3 → 1-3 +1= -1 → overlap0.

merged_count =1 (size of x's range) +1 (count of a_x's) -0 =2.

Thus, the model would give count=2.

But this contradicts the earlier calculation.

Wait, what's the correct calculation.

For x=3, k=0.

x's range is [3,3].

a_x=1's range is [1,1].

The union is {3,1} →2 elements.

So the model should return2.

But according to the new approach:

x=1's count is1 (range [1,1]).

x=3's count is 1 (x's range) +1 (a_x's count) - overlap.

 overlap between [3,3] and [1,1] is0.

So count[x=3] =1+1-0=2. Which is correct.

Ah! So in this case, the model works.

But earlier example:

x=5, a_x=3, a_3=1.

For x=5:

x's range is5.

a_x=3's merged interval is [1,3], count=2 (3's range and 1's range).

 overlap between5 and [1,3] is0.

count[x=5] =1+2-0=3.

The union is5,3,1 →3 elements. Correct.

Thus, the model works.

Earlier mistake was in calculating the merged interval for x=3. Let's re-calculate:

x=3, k=0:

lx=3, rx=3.

a_x=1:

process x=1.

 merged interval [1,1], count=1.

 merged_L = min(3, 1) =1.

 merged_R = max(3, 1) =3.

 overlap between [3,3] and [1,1] is0.

 count[x=3] =1 (3's range) +1 (a_x's count) -0 =2.

 merged interval is [1,3], count=2.

So for x=5:

merged interval is [1,5], count=3.

So the model works.

Thus, the approach is correct.

So the correct way to model the problem is to track for each x the merged interval [L[x], R[x]] and the count of messages in the union of ranges. The count is computed as the size of x's range plus the count from the linked x's chain minus the overlap between x's range and the merged interval of the linked x's chain.

Thus, the algorithm is:

For each x in 1..n:

- Compute lx = max(1, x -k)

- rx = min(n, x +k)

- if a[x] == 0:

   L[x] = lx

   R[x] = rx

   count[x] = rx - lx + 1

- else:

   y = a[x]

   recursively compute L[y], R[y], count[y]

   merged_L = min(lx, L[y])

   merged_R = max(rx, R[y])

   overlap = max(0, min(rx, R[y]) - max(lx, L[y]) + 1)

   count[x] = (rx - lx + 1) + count[y] - overlap

   L[x] = merged_L

   R[x] = merged_R

The answer for x is count[x].

This approach correctly handles all cases, including those where the merged interval is contiguous but there are gaps between ranges. Because the overlap is computed based on the merged interval of the linked x's chain.

Thus, this is the correct approach.

Now, we need to implement this in Python.

But for n=1e5, recursion is not feasible. So we need to process the nodes in topological order, as the a[x] for each x is less than x. Thus, we can process the nodes in order from 1 to n.

We can use memoization with iteration.

Thus, the algorithm can be implemented with dynamic programming:

Initialize L and R and count arrays.

For x from 1 to n:

   lx = max(1, x -k)

   rx = min(n, x +k)

   if a[x] ==0:

       L[x] = lx

       R[x] = rx

       count[x] = rx - lx +1

   else:

       y = a[x]

       merged_L = min(lx, L[y])

       merged_R = max(rx, R[y])

       overlap = max(0, min(rx, R[y]) - max(lx, L[y]) +1)

       count[x] = (rx - lx +1) + count[y] - overlap

       L[x] = merged_L

       R[x] = merged_R

Thus, this can be computed in O(n) time.

Let's test this on the sample cases.

Sample 1:

n=6, k=0.

a = [0,1,1,2,3,2].

Processing x=1:

a[1]=0.

L[1]=1, R[1]=1.

count=1.

x=2:

a[2]=1.

lx=2, rx=2.

y=1: L[y]=1, R[y]=1.

merged_L= min(2,1)=1.

 merged_R= max(2,1)=2.

 overlap= min(2,1)=1 - max(2,1)=2 → -1 →0.

count=1 (2-2+1) + count[1] (1) -0 =1 +1=2.

L[2] =1, R[2]=2.

x=3:

a[3]=1.

lx=3, rx=3.

y=1: L[y]=1, R[y]=1.

merged_L= min(3,1)=1.

 merged_R= max(3,1)=3.

 overlap= min(3,1)=1 - max(3,1)=3 →-2 →0.

count=1 +1 -0=2.

L[3]=1, R[3]=3.

x=4:

a[4]=2.

y=2. L[y]=1, R[y]=2.

lx=4, rx=4.

merged_L= min(4,1)=1.

 merged_R= max(4,2)=4.

 overlap= min(4,2)=2 - max(4,1)=4 →-2 →0.

count=1 (4-4+1) +2 (count[2]) -0=3.

L[4]=1, R[4]=4.

x=5:

a[5]=3.

y=3. L[y]=1, R[y]=3.

lx=5, rx=5.

merged_L= min(5,1)=1.

 merged_R= max(5,3)=5.

 overlap= min(5,3)=3 - max(5,1)=5 →-2 →0.

count=1 +2 -0=3.

L[5] =1, R[5]=5.

x=6:

a[6]=2.

y=2. L[y]=1, R[y]=2.

lx=6, rx=6.

merged_L= min(6,1)=1.

 merged_R= max(6,2)=6.

 overlap= min(6,2)=2 - max(6,1)=6 →-4 →0.

count=1 +2 -0=3.

Which matches the sample output.

Thus, the model works.

Another test case where x=5, a_x=3, a_3=1, k=0:

Processing:

x=1: count=1.

x=3: a_x=1.

count=1 +1 -0=2.

x=5: a_x=3.

count=1 +2 -0=3.

Which is correct.

Thus, the model works.

Thus, the approach is correct.

Now, to implement this in Python.

The steps are:

1. Read n and k.

2. Read a as a list of integers. Note that the list is 1-based? Or 0-based?

The input says the second line is a sequence a_1, a_2, ..., a_n. So the array is 0-based in Python but the input is 1-based.

Wait, no. The input is given as a_1, a_2, ..., a_n. So in Python, we'll read them as a list where a[0] is a_1 (but since in Python list is 0-based, but the messages are 1-based, we need to adjust.

Wait, no. The messages are 1-based, so the first message is 1, which has a_1 in the input. So in Python, the array a is zero-based but represents a_1 to a_n. So in the code, for message i (1-based), a[i-1] is the value.

So for example, message 6 has a_6 given as the sixth element in the input list.

So in code:

n, k = map(int, input().split())

a = list(map(int, input().split()))

Then, for message i (1-based), a[i-1] is the link.

We need to process each message from 1 to n.

We can create arrays L, R, count, all of size n+1 (since messages are 1-based).

Initialize L, R, count as arrays of size n+1.

For x in range 1 to n:

   lx = max(1, x -k)

   rx = min(n, x +k)

   if a[x-1] ==0:

       L[x] = lx

       R[x] = rx

       count[x] = rx - lx +1

   else:

       y = a[x-1]

       merged_L = min(lx, L[y])

       merged_R = max(rx, R[y])

       overlap = max(0, min(rx, R[y]) - max(lx, L[y]) +1)

       count[x] = (rx - lx +1) + count[y] - overlap

       L[x] = merged_L

       R[x] = merged_R

Finally, output count[1], count[2], ..., count[n].

But wait, in the case where a[x-1] is non-zero, y is a[x-1], which is less than x.

So when processing x in order from 1 to n, y will have been processed before x.

Thus, the order of processing is correct.

Now, implement this.

Test the first sample:

Input:

6 0

0 1 1 2 3 2

n=6, k=0.

a = [0,1,1,2,3,2].

Processing x=1:

a[0] is0.

L[1] =1.

R[1] =1.

count[1] =1.

x=2:

a[1]=1.

y=1.

merged_L = min(2, 1) =1.

merged_R = max(2,1) =2.

overlap = max(0, min(2,1) - max(2,1) +1) → min(2,1)=1. max(2,1)=2. 1-2+1=0.

count[x=2] = (2-2+1) +1 -0 →1+1=2.

x=3:

a[2]=1.

y=1.

merged_L = min(3,1)=1.

merged_R = max(3,1)=3.

overlap= min(3,1)=1. max(3,1)=3. 1-3+1= -1 → max(0, ...) →0.

count=1+1-0=2.

x=4:

a[3]=2.

y=2.

L[y]=1, R[y]=2.

lx=4, rx=4.

merged_L= min(4,1) =1.

merged_R= max(4,2) =4.

overlap= min(4,2)=2 - max(4,1)=4 →2-4+1= -1 →0.

count=1 +2 -0=3.

x=5:

a[4]=3.

y=3.

L[y]=1, R[y]=3.

lx=5-0=5, rx=5.

merged_L= min(5,1)=1.

merged_R= max(5,3)=5.

overlap= min(5,3)=3 - max(5,1)=5 →3-5+1= -1 →0.

count=1 +2 -0=3.

x=6:

a[5]=2.

y=2.

L[y]=1, R[y]=2.

lx=6, rx=6.

merged_L=1, merged_R=6.

overlap= min(6,2)=2 - max(6,1)=6 →2-6+1= -3 →0.

count=1 +2 -0=3.

Thus, the output is 1 2 2 3 3 3. Which matches the first sample.

Thus, the code works.

Another test case:

Sample 2:

input:

10 1

0 1 0 3 4 5 2 3 7 0

output:

2 3 3 4 5 6 6 6 8 2

Let's compute count for x=6.

x=6:

a[5]=5.

y=5.

lx=6-1=5, rx=6+1=7.

For y=5:

a[4]=4.

y=4.

For y=4:

a[3]=3.

y=3.

For y=3:

a[2]=0.

lx=3-1=2, rx=3+1=4.

L[3]=2, R[3]=4. count=3.

For y=4:

lx=4-1=3, rx=4+1=5.

merged_L= min(3, 2) =2.

merged_R= max(5,4) =5.

overlap= min(5,4)=4 - max(3,2)=3 →4-3+1=2.

count=3 (5-3+1) +3 -2=3+3-2=4.

L[4]=2, R[4]=5.

y=5:

a[4]=4.

lx=5-1=4, rx=5+1=6.

merged_L= min(4,2)=2.

merged_R= max(6,5)=6.

overlap= min(6,5)=5 - max(4,2)=4 →5-4+1=2.

count= (6-4+1)=3 +4 (count[4]) -2=3+4-2=5.

L[5]=2, R[5]=6.

Now x=6:

merged_L= min(5,2)=2.

merged_R= max(7,6)=7.

overlap= min(7,6)=6 - max(5,2)=5 →6-5+1=2.

count= (7-5+1=3) +5 -2=6.

Which matches the sample output.

Thus, the code works.

Now, the code:

We can implement this with arrays L, R, count, all 1-based.

So here's the code:

Read n, k.

Read a list.

Initialize L, R, count as lists of size n+1.

Loop x from 1 to n:

   lx = max(1, x -k)

   rx = min(n, x +k)

   if a[x-1] ==0:

       L[x] = lx

       R[x] = rx

       count[x] = rx - lx +1

   else:

       y = a[x-1]

       merged_L = min(lx, L[y])

       merged_R = max(rx, R[y])

       overlap = max(0, min(rx, R[y]) - max(lx, L[y]) +1)

       count[x] = (rx - lx +1) + count[y] - overlap

       L[x] = merged_L

       R[x] = merged_R

Print count[1], count[2], ..., count[n].

Now, implement this.

But in Python, for n up to 1e5, this is feasible.

So the code is:

Read n and k.

Read a as a list of integers.

Initialize L, R, count as lists of size n+1.

For x in range(1, n+1):

   lx = max(1, x - k)

   rx = min(n, x + k)

   if a[x-1] == 0:

       L[x] = lx

       R[x] = rx

       count[x] = rx - lx + 1

   else:

       y = a[x-1]

       merged_L = min(lx, L[y])

       merged_R = max(rx, R[y])

       overlap = max(0, min(rx, R[y]) - max(lx, L[y]) + 1)

       count[x] = (rx - lx +1) + count[y] - overlap

       L[x] = merged_L

       R[x] = merged_R

Print ' '.join(map(str, count[1:]))

Let's test this code.

Sample 1:

Input:

6 0

0 1 1 2 3 2

Code output is 1 2 2 3 3 3.

Sample 2:

Input:

10 1

0 1 0 3 4 5 2 3 7 0

Output:

2 3 3 4 5 6 6 6 8 2.

Which matches.

Sample3:

Input:

2 2

0 1

Output:

2 2.

For x=1:

lx= max(1,1-2)=0 → clamped to 1.

rx= min(2,1+2)=3 → clamped to2.

range is1-2.

a[x-1]=0.

count[1] =2.

x=2:

a[x-1]=1.

y=1.

merged_L= min(0 (2-2=0, clamped to1), 1) →1.

merged_R= max(2+2=4 →min(2,4)=2, R[y]=2.

overlap= min(4,2) - max(0,1) +1 →2-1+1=2.

count[x=2] = (4-0+1=5 clamped to 2-1+1=2) ? Wait, no.

Wait, for x=2:

lx = max(1, 2-2=0) →1.

rx = min(2, 2+2=4) →2.

So rx - lx +1 = 2-1+1=2.

y=1.

L[y] =1, R[y] =2.

merged_L = min(1,1) =1.

merged_R = max(2,2) =2.

overlap= min(2,2) - max(1,1) +1 →2-1+1=2.

count[x=2] =2 (size of x's range) +2 (count[y]) -2 (overlap) →2+2-2=2.

So output is 2 and 2, which matches the sample.

Thus, the code works.
</think>

```python
n, k = map(int, input().split())
a = list(map(int, input().split()))

L = [0] * (n + 1)
R = [0] * (n + 1)
count = [0] * (n + 1)

for x in range(1, n + 1):
    lx = max(1, x - k)
    rx = min(n, x + k)
    if a[x - 1] == 0:
        L[x] = lx
        R[x] = rx
        count[x] = rx - lx + 1
    else:
        y = a[x - 1]
        merged_L = min(lx, L[y])
        merged_R = max(rx, R[y])
        overlap = max(0, min(rx, R[y]) - max(lx, L[y]) + 1)
        count[x] = (rx - lx + 1) + count[y] - overlap
        L[x] = merged_L
        R[x] = merged_R

print(' '.join(map(str, count[1:])))
```