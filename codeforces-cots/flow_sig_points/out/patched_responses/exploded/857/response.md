<think>
Okay, I need to solve this problem where I have to find the largest number less than or equal to x that has the maximum sum of digits. Hmm. Let's think about how to approach this.

First, let's understand the problem. For a given x, we need to check all numbers from x down to 1 and find the one with the maximum digit sum. But since x can be up to 1e18, checking each number one by one is impossible due to time constraints. So we need a smarter approach.

The brute force approach is out of the question. So what's the pattern here? The maximum digit sum for numbers <=x would likely be a number with as many 9s as possible. For example, in the first example, 100, the best is 99. So maybe the approach is to find the first digit that can be reduced by 1, then set all following digits to 9. But there might be multiple possibilities here, so we need to check all possible candidates.

Wait, here's an idea. For each position in the number, if we can decrease that digit by 1 and replace all the following digits with 9, then compute the digit sum. The maximum among all these possibilities and the original number is the answer.

For example, take x as 521. The original digit sum is 5+2+1=8. Let's look for possible candidates:
- Decrease the first digit (5) by 1 to 4, then set the rest to 99: 499. Sum is 4+9+9=22.
- Decrease the second digit (2) by 1 to 1, set the rest to 9: 519 (since after the second digit, there's only the third digit. So sum is 5+1+9=15.
- Decrease the third digit (1) by 1 to 0, set the rest (none) to 9: 520. Sum is 5+2+0=7.

So the maximum is 499. So the approach is to generate all possible candidates by decreasing each digit (if possible) and setting the following digits to 9, then compute their sum. Then choose the maximum among all these candidates and the original x.

That makes sense. So the steps would be:

1. Generate all possible candidates by checking each digit in x. For each digit, if it's not zero, decrease it by one and set all digits to the right to 9. Then add this candidate to the list.
2. Also include the original x as a candidate.
3. For each candidate, compute the sum of digits.
4. Among all candidates, select the one with the maximum sum. If there's a tie, pick the largest number.

Wait, but when generating the candidates, some of them might be larger than x. Like, if x is 48, the original number's sum is 12. If we try decreasing the first digit (4) to 3 and set the rest to 9: 39. Sum is 12. But the original is 48, which is larger. So in this case, the maximum sum is 12, and the largest number with that sum is 48, so we output it.

So the process is correct. So the plan is:

- Convert x to a string to process each digit.
- Iterate through each position in the string. For each position i:
   - If the digit is '0', skip (since we can't decrease it by 1 and have a non-negative digit).
   - Otherwise, create a new number where digit i is decreased by 1, and all digits after i are '9'.
   - Add this number to the list of candidates.
- Also add the original x to the candidates.
- For each candidate, compute the sum of digits.
- Find the candidate with the maximum sum. If multiple, pick the largest number.

This approach should generate all possible candidates that could have a higher digit sum than the original. For example, in the case where x is 999, the original sum is 27, and all candidates generated by the process would have lower sums, so the original is the best.

Now, the question is how to efficiently generate all these candidates and compute their digit sums.

Let's think about how to generate the candidates. For the number 521, which is '5','2','1', the candidates are:

Original: 521 (sum 8)
Decreasing first digit to 4, rest 99: 499 (sum 22)
Decreasing second digit to 1, rest 9: 519 (sum 15)
Decreasing third digit to 0, rest (nothing): 520 (sum 7)
So all these candidates are considered.

So for each digit position, we generate a candidate. The number of candidates is O(n), where n is the number of digits (up to 18), so this is feasible.

So the steps in code:

1. Read x as a string. For example, x = input().strip()
2. Generate all candidates. For each i in 0 to len(x)-1:
   a. If x[i] is '0', skip.
   b. Take the substring up to i, then decrease x[i] by 1, then append '9's for the remaining digits.
3. Also add the original x to the list.
4. For each candidate, convert to integer (but to compare, maybe we can process as a string to avoid leading zeros)
5. For each candidate, compute the sum of digits.
6. Find the candidate with the maximum sum. If there's a tie, pick the largest number.

Wait, but leading zeros could be a problem. For example, if x is 1000, then when we process the first digit (1), decrease to 0, then set the rest to 9. So the candidate becomes 0999. But leading zeros are not allowed, so we need to treat that as 999, which is 999. So when generating the candidate, we need to check if the new candidate starts with zeros. For example, if the first digit is 1, and we decrease it to 0, then the candidate is 0 followed by 9s, which would be invalid as a number (but when parsed as an integer, leading zeros are removed). So in code, when generating the candidate, after creating the new string, we can convert it to an integer to automatically remove leading zeros, then convert back to string to check for sum and to compare.

Wait, but perhaps the sum can be calculated directly from the candidate string, even with leading zeros, but when the candidate is converted to integer, leading zeros are removed, but the actual value is correct.

Alternatively, when generating the candidate, after modifying the digits, we can check if the first digit is '0'. If so, then we need to ignore leading zeros. But perhaps it's easier to generate the candidate as a string, then convert it to an integer (to handle leading zeros correctly), then convert back to a string (without leading zeros) for processing.

But perhaps when generating the candidate, when the first digit is '0', then the candidate is invalid (since the number must be positive and not have leading zeros). Wait, but the candidate can be something like 0999, which is equivalent to 999, which is a valid positive integer. So when generating the candidate, the code must generate the number as a string, then when converting to integer, leading zeros are stripped. But when we compute the digit sum, we need to consider the actual digits. Wait, but no. For example, 0999's digit sum is 0+9+9+9=27, but when converted to integer, it's 999, which has sum 9+9+9=27. So if the candidate is '0999', when converted to integer, it's 999. But when computing the sum, it's the sum of the original digits. Wait, no: the problem states that the output must not have leading zeros, but the candidate must be the number that is <=x. So for example, if the candidate is 0999, it's actually 999, which is a valid candidate. So in this case, the candidate's sum is 9*3=27. So when generating the candidate, we need to process the digits as they would be when leading zeros are removed.

Wait, but how do we generate the candidate? For example, in the case where the first digit is decreased to 0, the rest are 9s. So the candidate would be 0 followed by all 9s. But when you convert that to an integer, it's the number formed by the 9s. So the sum would be 9*(n-1), where n is the number of digits. So perhaps the correct way is to generate the candidate as follows: when you decrease a digit, you create a new string, then when you compute the sum, you take the digits as in the new string, but leading zeros would contribute zero to the sum. So for example, the candidate '0999' would have a sum of 0+9+9+9=27, but when converted to integer, it's 999, which has sum 27. So in that case, the sum calculation is the same as the integer's sum. So perhaps the approach is to generate the candidate string, then when calculating the sum, process each character as a digit (including leading zeros if any). But when the candidate is '0', that's a problem (since x can be 1, but according to the problem statement, the output must be a positive integer). Wait, the problem says "positive integer which doesn't exceed x". So x can be 1, then the output is 1.

So for the candidate generation, when the first digit is zero, then the candidate is a number with leading zeros, but after conversion to integer, it's a smaller number. For example, x is 1000. The candidate generated by reducing the first digit is 0 followed by three 9s. So when converted to integer, it's 999. Which is a valid candidate. So in this case, when generating the candidate, the code must create the string, then convert to integer to get the correct number (stripping leading zeros), then check if that number is <=x.

Wait, but the candidate may be larger than x. Wait, how? Because when you decrease a digit and set the following digits to 9, the resulting number could be larger than x. For example, take x=555. If you decrease the third digit (5 to 4) and set the rest (none) to 9, you get 554. Which is smaller. But if you have x=45. If you decrease the first digit (4 to 3) and set the rest to 9, you get 39. Which is less than 45. So perhaps all generated candidates are <=x. Let's see:

Original x is a number. For each candidate generated by taking the first i digits, decreasing the i-th by 1, and setting the rest to 9. Let's see:

Original x: D1 D2 D3 ... Dn.

Suppose in candidate i, we have D1 D2 ... Di-1 (Di-1) followed by 9s. The original number is D1...Di ... Dn. The candidate is D1... (Di-1) followed by 9s. Since Di-1 is less than Di (since we are allowed to decrease Di only if it's non-zero), then the candidate must be less than the original number. For example, if x is 521, the candidate generated by the first digit (5 becomes 4, followed by 99) is 499, which is less than 521. So all generated candidates (except the original x) are less than x. Therefore, all candidates are valid (<=x), except perhaps when the candidate is generated by decreasing a digit in the middle and the following digits in the original are higher than 9 (but that's impossible because digits are 0-9). So the generated candidates are all <=x. So when generating the candidates, we don't need to check if they are <=x. They are automatically valid.

But wait, what if we have a digit that's already 9? For example, x is 999. Then, when trying to decrease a digit (like the first 9 to 8), the candidate becomes 899...9, which is less than 999. So the candidates are all valid.

So the candidates generated by this method are all valid (<=x). So we can safely generate all these candidates, include the original x, and then compute their digit sums.

So the steps in code:

1. Generate all possible candidates.

Now, for code, let's think:

x_str = input().strip()

candidates = [x_str]

for i in range(len(x_str)):
    if x_str[i] == '0':
        continue
    # create a new candidate by decreasing x_str[i] by 1, and setting the rest to 9
    new_num = x_str[:i] + str(int(x_str[i]) -1) + '9' * (len(x_str) - i -1)
    candidates.append(new_num)

Then, for each candidate in candidates, convert to integer (to remove leading zeros), then check if it's positive (but since original x is positive, and the candidates are <=x, except the original, which is x, they are all positive or zero. Wait, but the problem states that the output must be a positive integer. So for example, if x is 1, the candidate generated by decreasing the first digit would be 0, which is not positive. So in this case, the candidate 0 is invalid, but the original x is 1, which is valid.

So in code, after generating all candidates, we need to filter out any candidates that are zero. But how?

Wait, the original x is in the candidates. So when x is 1, the candidates are '1' and '0' (from decreasing the first digit). So when processing, we need to ensure that the candidate is a positive integer. So when generating the candidate, the new_num could be '0', which when converted to int is 0, which is not allowed. So in code, after generating all the candidates, we need to convert each to integer, then filter out any that are zero, and also the original x may be a candidate (like 0, but x is given as positive, so x is at least 1).

Wait, but the problem states that x is a positive integer. So the original x is at least 1. So the original x is a valid candidate. But the generated candidates could be zero. For example, x is 1000. The candidate generated by decreasing the first digit (1) to 0 and the rest to 999. So the candidate is 0999, which is 999 when converted to int. Which is allowed. But if x is 1, then the candidate is '0', which is invalid.

So in code, after generating all candidates, we need to process each candidate as follows:

- Convert the candidate string to integer. Then check if it's positive (>=1). If not, discard it.

So, the code steps:

Generate all candidate strings (original and modified ones).

For each candidate_str in candidates:

   candidate_int = int(candidate_str)

   if candidate_int < 1: skip

   else, add to the list of possible candidates.

But wait, in the case of x=1, the original x is 1 (valid), and the candidate generated by decreasing the first digit is 0 (invalid). So in that case, the valid candidates are only 1.

So in code, after generating all candidate_str, we need to convert them to int, check if they are >=1, and proceed.

So the code will:

- collect all candidate_str, convert to int, filter out those less than 1.

Then, among the remaining candidates, compute the sum of digits for each, and select the one with maximum sum. If tie, select the largest number.

So, the plan is:

Read x as a string.

Generate all possible candidate_strs as described.

Convert each to int and filter out those <1.

Then, for each candidate_int in the filtered list:

   compute sum of digits (can be done by converting to string and summing each digit, or via math)

   keep track of the maximum sum, and the largest candidate in case of tie.

Now, the next step is to compute the sum of digits for each candidate.

For example, for candidate 499, sum is 4+9+9=22.

So, code for sum of digits:

def digit_sum(n):
    s = 0
    while n > 0:
        s += n % 10
        n = n //10
    return s

But converting to int and then computing sum via this function may be faster than converting to a string and processing each character.

But for very large numbers (like 1e18), the string approach is acceptable, as the number has 18 digits. So processing each character is O(18), which is acceptable.

So, for each candidate_int in the filtered list, compute the sum of its digits.

Then, find the candidate with the highest sum. If there's a tie, select the largest candidate.

So, the code outline:

x_str = input().strip()

candidates = [x_str]

for i in range(len(x_str)):
    if x_str[i] == '0':
        continue
    new_num_str = x_str[:i] + str(int(x_str[i]) -1) + '9' * (len(x_str) - i -1)
    candidates.append(new_num_str)

valid_candidates = []
for c in candidates:
    num = int(c)
    if num >= 1:
        valid_candidates.append(num)

# Now compute for each valid candidate the sum and track the best
max_sum = -1
best_num = -1

for num in valid_candidates:
    s = sum(int(d) for d in str(num))
    if s > max_sum or (s == max_sum and num > best_num):
        max_sum = s
        best_num = num

print(best_num)

Wait, but converting the num to a string again to compute the sum. Alternatively, compute the sum when the candidate is generated as a string. Because the candidate_str is a string, perhaps we can compute the sum once when generating the candidate_str. For example, when generating '499', the sum is 4+9+9=22. Then, when converting to int, the sum is the same. So perhaps it's more efficient to compute the sum of the candidate_str (as a string) before converting to int.

But in code, this would involve for each candidate_str in candidates, compute the sum by iterating through each character (including leading zeros, if any). Then, for example, '0999' would have sum 0+9+9+9=27, but the actual number is 999, which has sum 27. So the sum is correct.

But if we compute the sum from the candidate_str, then leading zeros would contribute to the sum. But when the candidate_str is '0', the sum is 0, which is invalid. But in that case, the candidate is filtered out because the num is 0.

Wait, but when candidate_str is '0999', the sum computed as per the string is 0+9+9+9=27. The num is 999, which has sum 27. So the sum is the same. Therefore, it's possible to compute the sum from the candidate_str (before converting to int) and avoid converting the num to string again. This would be more efficient.

So the code can be optimized as follows:

For each candidate_str in candidates:

   if the candidate_str is all zeros (like '0'), then the num is 0, which is invalid.

   else:

       sum_digits = sum of each character in candidate_str converted to int.

       then, num = int(candidate_str)

       if num >=1:

           add (sum_digits, num) to the list.

Then, find the (sum_digits, num) with the highest sum_digits, and in case of tie, the highest num.

This approach would avoid converting the num back to a string to compute the sum. For example, for '0999', sum_digits is 27, num is 999. So when we process the candidate_str, we compute sum_digits as 0+9+9+9=27, then check if the num (999) is >=1. So this is valid.

But for the original candidate_str (x_str), which could be something like '100', the sum is 1+0+0=1, but the num is 100. So sum_digits is 1. But when generating the candidate_str '099' (from 100), sum_digits is 0+9+9=18, num is 99. So sum is 18.

So in code, compute the sum_digits from the candidate_str, then check if the num (int(candidate_str)) is >=1. If so, add to the list.

So this approach is valid and more efficient.

So the code steps would be:

candidates = [x_str] + the generated ones.

processed = []

for candidate_str in candidates:

    num = int(candidate_str)

    if num < 1:

        continue

    sum_d = sum(int(c) for c in candidate_str)

    processed.append( (sum_d, num) )

Then, among all processed entries, find the one with maximum sum_d, and largest num in case of ties.

This would be more efficient because for each candidate_str, the sum is computed once, and the num is computed once.

So the code becomes:

Testing against sample input 1.

```python
def main(input_stream, output_stream):
    x_str = input_stream.readline().rstrip("\n").strip()

    candidates = [x_str]

    n = len(x_str)

    for i in range(n):
        if x_str[i] == '0':
            continue
        # create the new candidate string
        new_str = x_str[:i] + str(int(x_str[i]) -1) + '9' * (n - i -1)
        candidates.append(new_str)

    max_sum = -1
    best_num = -1

    for candidate in candidates:
        # compute sum and num
        num = int(candidate)
        if num <1:
            continue
        s = sum(int(c) for c in candidate)
        if s > max_sum or (s == max_sum and num > best_num):
            max_sum = s
            best_num = num

    print(best_num, file=output_stream)



def test():
    import io

    TEST_CASES = [
        {
            "input": \
"""\
48
""",
            "output": \
"""\
48
""",
        }, 
    ]

    for i, test_case in enumerate(TEST_CASES):
        in_stream = io.StringIO(test_case["input"])
        expected_output = test_case["output"].rstrip()

        out_stream = io.StringIO()
        main(in_stream, out_stream)
        real_output = out_stream.getvalue().rstrip()

        assert real_output == expected_output, \
            f'Test case {i} failed.\nExpected: {expected_output!r}\nGot: {real_output!r}'

    print('Tests passed ðŸ˜Ž')


if __name__ == '__main__':
    test()


```

<RUN_SNIPPET>
```output
Tests passed ðŸ˜Ž

```

Testing against sample input 2.

```python
def main(input_stream, output_stream):
    x_str = input_stream.readline().rstrip("\n").strip()

    candidates = [x_str]

    n = len(x_str)

    for i in range(n):
        if x_str[i] == '0':
            continue
        # create the new candidate string
        new_str = x_str[:i] + str(int(x_str[i]) -1) + '9' * (n - i -1)
        candidates.append(new_str)

    max_sum = -1
    best_num = -1

    for candidate in candidates:
        # compute sum and num
        num = int(candidate)
        if num <1:
            continue
        s = sum(int(c) for c in candidate)
        if s > max_sum or (s == max_sum and num > best_num):
            max_sum = s
            best_num = num

    print(best_num, file=output_stream)



def test():
    import io

    TEST_CASES = [
        {
            "input": \
"""\
521
""",
            "output": \
"""\
499
""",
        }, 
    ]

    for i, test_case in enumerate(TEST_CASES):
        in_stream = io.StringIO(test_case["input"])
        expected_output = test_case["output"].rstrip()

        out_stream = io.StringIO()
        main(in_stream, out_stream)
        real_output = out_stream.getvalue().rstrip()

        assert real_output == expected_output, \
            f'Test case {i} failed.\nExpected: {expected_output!r}\nGot: {real_output!r}'

    print('Tests passed ðŸ˜Ž')


if __name__ == '__main__':
    test()


```

<RUN_SNIPPET>
```output
Tests passed ðŸ˜Ž

```

Sample 3:

Input: 521.

Original sum is 5+2+1=8. Candidates:

i=0: '4' followed by 99 â†’ 499. sum 4+9+9=22.

i=1: '5' followed by 1-1=1 â†’ '51' followed by 9: 519. sum 5+1+9=15.

i=2: '52' followed by 0 â†’ 520. sum 5+2+0=7.

So the candidates are 521 (sum 8), 499 (sum 22), 519 (sum 15), 520 (sum 7). So the best is 499.

So the code should handle these cases correctly.

Now, check another case where leading zeros are in the candidate_str. For example, x=1000.

Original sum is 1+0+0+0=1.

Candidates generated by i=0: '0999' â†’ num 999. sum 0+9+9+9=27.

i=1: x_str[1] is 0 â†’ skip.

i=2: x_str[2] is 0 â†’ skip.

i=3: x_str[3] is 0 â†’ skip.

So the candidates are '1000', '0999', '0999', etc. But in code, the candidate_str for i=0 is '0999', which when converted to num is 999. sum_digits is 27.

So the best is 999.

Another test case: x= 999.

Original sum is 27.

Candidates generated by each i:

For i=0: 8999 â†’ sum 8+9+9+9=35? Wait, wait, x_str is '999', len 3. For i=0, new_str is '8' followed by two 9s. sum is 8+9+9=26. num is 899. Which is less than 999.

But original sum is 27. So the best is original.

So code would select 999.

Another test case: x= 9. The candidates are '9' and for i=0, '8' (sum 8). So the original sum is 9. So output is 9.

Edge case: x=1. Candidates are '1' and '0'. The '0' is invalid. So output is 1.

So the code should handle all these cases.

Now, code looks correct. Let's test for leading zeros in the candidate_str. For example, x= 500.

Candidates:

i=0: '499' â†’ sum 4+9+9=22.

i=1: '490' â†’ sum 4+9+0=13.

i=2: '509' â†’ sum 5+0+9=14.

So the best is 499.

So code works.

Now, the code should be efficient. Generating up to 18 candidates (since x can be up to 1e18, len(x_str) is 18). For each candidate, sum is O(18) steps, which is negligible. So even for the worst case, the code runs in O(18*18) steps, which is acceptable.

So the code should pass all test cases and be efficient.
</think>

```python
x_str = input().strip()
candidates = [x_str]
n = len(x_str)

for i in range(n):
    if x_str[i] == '0':
        continue
    new_str = x_str[:i] + str(int(x_str[i]) - 1) + '9' * (n - i - 1)
    candidates.append(new_str)

max_sum = -1
best_num = -1

for candidate in candidates:
    num = int(candidate)
    if num < 1:
        continue
    current_sum = sum(int(c) for c in candidate)
    if current_sum > max_sum or (current_sum == max_sum and num > best_num):
        max_sum = current_sum
        best_num = num

print(best_num)
```
