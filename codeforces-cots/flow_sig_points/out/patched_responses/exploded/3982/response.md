<think>
Okay, I need to solve this problem where Mike has to rotate all his strings so that they all become the same with the minimal number of moves. Let's think about how to approach this.

First, the problem says that each rotation takes the first character and appends it to the end. So for example, rotating "abc" once would give "bca", then "cab", then back to "abc" after three rotations. So each string can be rotated any number of times, and we need to find a target string (which is some rotation of one of the original strings) that all other strings can be rotated to, using the least total moves.

The main steps I need to take are:

1. For each string, generate all possible rotations. For a string of length L, there are L possible rotations (including zero rotations). For each rotation, note the number of moves needed to reach that rotation from the original string. For example, the original string is 0 moves, rotating once is 1 move, etc.

2. For each possible target rotation (from all rotations of the first string), check if all other strings can be rotated to match this target. If yes, sum the moves required for each string to reach this target. The minimal such sum across all valid targets is the answer.

3. If none of the targets from the first string's rotations can be matched by all other strings, then output -1.

But wait, why take the first string's rotations as possible targets? Because if there exists a common target that all strings can rotate into, then that target must be a rotation of each string. So, the target must be present in the rotations of every string. So, perhaps the correct approach is to check all possible rotations of the first string as possible candidates. For each candidate, check if all other strings have that rotation in their possible rotations. If yes, then sum the required moves for each string to reach that candidate. The minimal sum across all possible candidates is the answer.

Yes, that makes sense. Because the first string's rotations are the only possible candidates that we need to check. Because if there's a target that isn't a rotation of the first string, then the first string can't reach it by rotation, hence the answer would be -1.

So, here's the plan:

- For the first string, generate all possible rotations and their required moves. Let's call these possible targets.
- For each target in these possible targets:
   - For each other string in the list:
      - Check if the target can be found in the rotations of that string.
      - If any string doesn't have the target as one of its rotations, skip this target.
      - Otherwise, collect the required moves from each string to reach the target.
   - If all strings can reach the target, calculate the total moves for this target and track the minimum.
- After checking all possible targets from the first string, return the minimum sum found, or -1 if none are valid.

Now, let's think about how to efficiently generate rotations and check if a target exists in another string's rotations.

For a given string s of length L, its rotations can be generated by taking s[i:] + s[:i] for i in 0 to L-1. For example, for "abcd", the rotations are "abcd" (0 moves), "bcda" (1), "cdab" (2), "dabc" (3). Each rotation requires i moves, where i is the shift (since each move shifts by one character). So for the i-th rotation, the number of moves needed is i.

But wait, when we rotate a string once, the first character is moved to the end. So for each rotation, the number of moves needed to reach that rotation is exactly the index i. For example, rotating 0 times gives the original string (0 moves), rotating once gives the string after 1 move, etc.

So for each string, we can precompute a list of all possible rotations and their corresponding move counts. Then, for each possible target (from the first string's rotations), we can check if every other string has that target in their rotations. For each such target, sum the moves from each string to reach it.

The key steps are:

1. Precompute for each string a dictionary (or a list) that maps each possible rotation to the minimal number of moves required to reach it. Wait, but for each rotation, there's only one possible move count. For example, if a rotation is achieved by shifting i times, then the move count is i.

But perhaps for a given rotation, there might be multiple shifts that result in the same string. For example, if the string is "aaa", then all rotations are the same, so the move counts can be 0, 1, 2, etc. So, when a string has multiple shifts that result in the same rotation, we can take the minimal move count. Wait, but the problem says, what's the minimal number of moves for each string to reach the target. So for a string with rotations that have the same value, we can pick the smallest move count for that target.

Wait, no. For example, if the target is "aaa", then the string "aaa" can reach it in 0, 1, 2, etc. moves. So the minimal move count for this string to reach the target is 0. But if the target is one of the rotations, then for each string, we need to find the minimal moves required to reach that target. Because adding up the minimal moves from each string gives the total minimal.

So for each target rotation (from the first string's possible rotations), we need to check for each other string whether that rotation is present in their possible rotations, and if so, what is the minimal move count (i.e., the smallest i such that rotating i times gives the target). If any string doesn't have the target in their rotations, then this target is invalid.

Therefore, for each string, we can precompute a dictionary where the keys are the possible rotations and the values are the minimal move counts (i) for that rotation.

So the steps are:

- For each string s in the input list:
   - Generate all possible rotations (s shifted by i positions, for i in 0 to len(s)-1)
   - For each rotation, if it's already a key in the dictionary, keep the minimal i. But since each i produces a unique rotation (unless the string has repeating patterns), but for strings like "aaa", all rotations are the same, so the dictionary would have the same key for all i. But in that case, the minimal i is 0. Wait, no. For example, if the original string is "aaa", then rotating it 0 times gives "aaa", which requires 0 moves. Rotating once gives "aaa" again, which would require 1 move. But if the target is "aaa", then the minimal moves for this string is 0. So the dictionary for "aaa" would have key "aaa" mapped to 0 (since that's the smallest possible i for that rotation).

Wait, no. The rotations are generated by shifting 0,1,...,L-1 times. For each shift, the rotation is s shifted by i positions. For a string like "aaa", all these rotations are the same. So for each shift i, the rotation is "aaa". So the dictionary for this string would have "aaa" mapped to the minimal i (which is 0) because when you check all shifts, the earliest occurrence (i=0) gives the minimal move count.

But perhaps for a given rotation, the minimal i is the first occurrence. For example, for a string that cycles after some shifts, like "abab". The rotations would be:

i=0: abab (0 moves)
i=1: baba (1 move)
i=2: abab (2 moves)
i=3: baba (3 moves)
So for the rotation "abab", the minimal i is 0. For "baba", it's 1.

So the approach would be, for each string, when generating all possible rotations, for each rotation, we check if it's already in the dictionary. If not, add it with the current i. If it is already present, we leave it as the existing i (since it's the minimal). Because when we generate the rotations in order of i from 0 to L-1, the first occurrence (smallest i) would be the minimal move count.

Yes. So for each string, we can generate all possible rotations in order of i from 0 to len(s)-1. For each rotation, we add it to a dictionary only if it's not present. That way, the first occurrence (smallest i) is stored. So the dictionary for a string will map each possible rotation to the minimal i required to reach it.

Therefore, for each string, create a dictionary of rotations to their minimal move counts.

So, the plan is:

1. For each string in the input list, generate a dictionary that maps each possible rotation to the minimal number of moves required to reach it (the earliest i where the rotation is achieved).

2. Take all possible rotations of the first string as possible targets. For each such target:

   a. Check if all other strings have this target in their rotations dictionary.

   b. If all strings have the target, compute the sum of the move counts for each string to reach this target.

3. The minimal such sum across all targets is the answer. If no target exists where all strings can reach it, return -1.

Now, implementing this:

First, how to generate the rotations and the minimal move counts for each string.

For a string s, length L. For i in 0 to L-1:

rotation = s[i:] + s[:i]

If rotation is not in the dictionary, add it with value i.

Once all i are processed, the dictionary is built.

So, for each string s, we can create a dictionary.

Now, for the first string, collect all possible rotations. For each rotation in that dictionary, we need to check if all other strings have this rotation in their dictionaries.

If yes, sum all the moves (from each string's dictionary) and track the minimum sum.

If none of the first string's rotations are present in all other strings' dictionaries, output -1.

But wait, the first string's rotations may have multiple entries in their dictionary. For example, for the first string being "aaa", the dictionary will have "aaa" mapped to 0. So for each possible rotation (only "aaa" in this case), check if all other strings can reach it.

So, in code:

Read all the strings into a list.

If the list is empty, return 0 (but according to constraints, n is at least 1).

For each string, generate its rotation dictionary.

Then:

Take the first string's rotation dictionary, and for each possible target in its keys:

   total = 0

   for each string in the list:

      if target is not in the string's rotation dict:

          break and mark this target as invalid.

      else:

          add the move count from the string's dict for this target.

   if all strings have the target:

       track the minimal total.

If any targets are valid, return the minimal total. Else, return -1.

So, this approach should work.

Now, let's see about handling the input and generating the dictionaries.

In Python, for a string s, we can generate all rotations as follows:

For example, s = 'abcd', length 4.

i=0: abcd

i=1: bcda

i=2: cdab

i=3: dabc

Each rotation is s[i:] + s[:i].

Yes.

Now, for each string in the input, we can create a dictionary.

But wait, the problem says that all strings have the same length. So len(s1) == len(s2) ... == len(sn). But we should check this. However, according to the input constraints, the problem says that "lengths of strings are equal". So we can assume that all strings have the same length. So for each target rotation of the first string, all other strings must have the same length (so their rotations can match).

But in code, perhaps we can proceed without checking, but the problem statement ensures that all input strings have the same length.

Now, code steps:

Read n.

Read n lines as a list of strings.

If n is 1, then output 0, since no moves are needed.

Else:

Generate for each string a rotation dictionary.

Then, for each possible target in the first string's rotation dict:

   sum_moves = 0

   valid = True

   for each string in the list:

       if target not in string's rotation dict:

           valid = False

           break

       sum_moves += string's rotation dict[target]

   if valid:

       track the minimum sum_moves.

If any valid sum, output the minimum. Else, -1.

But wait, for the first string, the sum_moves includes the moves for the first string. But the first string's rotation dict's target's move count is the minimal required to reach that rotation. So for the first string, the move count is part of the sum.

Yes.

Now, the code.

But let's test with the examples.

First example:

4

xzzwo

zwoxz

zzwox

xzzwo

The first string is "xzzwo".

Let's generate all rotations:

Length is 5.

i=0: xzzwo â†’ moves 0.

i=1: zzw o x â†’ wait, original is "xzzwo". i=1: s[1:] is 'zzwo', s[:1] is 'x' â†’ 'zzwo' + 'x' â†’ 'zzwox' â†’ moves 1.

i=2: 'zwo' + 'xz' â†’ 'zwoxz' â†’ moves 2.

i=3: 'wox' + 'zz' â†’ 'woxzz' â†’ moves 3.

i=4: 'oxzzw' â†’ moves 4.

Wait, no. Wait for "xzzwo", the rotations would be:

i=0: xzzwo â†’ 0 moves.

i=1: zzwo + x â†’ zzwx? Wait, original is xzzwo. Let's split at i=1:

s[1:] is 'zzwo', s[:1] is 'x' â†’ 'zzwo' + 'x' â†’ 'zzwox' â†’ i=1.

i=2: s[2:] is 'zwo', s[:2] is 'xz' â†’ 'zwo' + 'xz' â†’ 'zwoxz' â†’ i=2.

i=3: s[3:] is 'wo', s[:3] is 'xzz' â†’ 'wo' + 'xzz' â†’ 'woxzz' â†’ i=3.

i=4: s[4:] is 'o', s[:4] is 'xzzw' â†’ 'o' + 'xzzw' â†’ 'oxzzw' â†’ i=4.

So the rotations of the first string are:

0: xzzwo â†’ move 0.

1: zzwox â†’ 1.

2: zwoxz â†’ 2.

3: woxzz â†’ 3.

4: oxzzw â†’4.

Wait, but in the first sample's note, the target is "zwoxz", which is the rotation of the first string at i=2 (moves 2). Then, the other strings are checked if they can reach this target.

The first string's rotation requires 2 moves. Let's see the other strings:

Second string is 'zwoxz'. Let's generate its rotations:

i=0: zwoxz â†’ 0 moves.

i=1: 'woxz' + 'z' â†’ 'woxzz' â†’ but wait, the string is 'zwoxz', length 5.

i=0: zwoxz â†’ 0.

i=1: woxz + z â†’ woxzz? Wait, no: the original is 'zwoxz', which is 5 characters. So for i=1, s[1:] is 'woxz', s[:1] is 'z' â†’ 'woxz' + 'z' â†’ 'woxzz' (i=1, moves 1).

i=2: oxz + zw â†’ oxzzw â†’ i=2.

i=3: xzz + two â†’ xzzwo â†’ i=3.

i=4: zzwo + x â†’ zzwox â†’ i=4.

So for the second string's rotations, does 'zwoxz' exist? Yes, at i=0. So for the target 'zwoxz', the second string's move count is 0.

Wait, but the target is 'zwoxz'. For the second string, when i=0, the rotation is 'zwoxz' (original), so move count 0.

Third string is 'zzwox'. Let's generate its rotations:

i=0: 'zzwox' â†’ 0.

i=1: 'zwox' + 'z' â†’ 'zwoxz' â†’ which is the target. So move count is 1.

Fourth string is 'xzzwo' again, same as the first string, which for the target 'zwoxz' requires 2 moves.

So sum would be 2 (first) + 0 (second) +1 (third) +2 (fourth) = 5. Which matches the sample.

So the code would check each of the first string's possible rotations as targets.

For the target 'zwoxz', which is in the first string's rotations (requires 2 moves), the code checks each other string:

Second string: has 'zwoxz' as a rotation (i=0, so move count 0).

Third string: 'zwoxz' is generated at i=1 (so move count 1).

Fourth string: same as first, requires 2 moves.

So sum is 2+0+1+2 =5. That's the minimal sum.

Now, how the code would process this.

Now, the code would generate all possible targets from the first string's rotations, and for each, check if all other strings can reach it.

The code would then select the sum with the minimal total moves.

So this approach works.

Now, for the code.

But in Python, dictionaries can be used to store the rotation to minimal moves.

Implementing this:

First, generate for each string its rotation dictionary.

So for each string s:

rot_dict = {}
for i in range(len(s)):
    rotated = s[i:] + s[:i]
    if rotated not in rot_dict:
        rot_dict[rotated] = i

Then, for the first string, collect all possible targets (keys in rot_dict), and for each, check all other strings' rot_dicts.

Now, in code:

Testing against sample input 2.

```python
def main(input_stream, output_stream):
    n = int(input_stream.readline().rstrip("\n"))
    strings = [input_stream.readline().rstrip("\n").strip() for _ in range(n)]

    if n == 1:
        print(0, file=output_stream)
        return

    # Precompute rotation dictionaries for each string
    rot_dicts = []
    for s in strings:
        d = {}
        l = len(s)
        for i in range(l):
            rotated = s[i:] + s[:i]
            if rotated not in d:
                d[rotated] = i
        rot_dicts.append(d)

    # Check all possible targets from the first string's rotations
    min_total = None
    for target, first_moves in rot_dicts[0].items():
        total = first_moves
        valid = True
        for i in range(1, n):
            s_dict = rot_dicts[i]
            if target not in s_dict:
                valid = False
                break
            total += s_dict[target]
        if valid:
            if min_total is None or total < min_total:
                min_total = total

    if min_total is not None:
        print(min_total, file=output_stream)
    else:
        print(-1, file=output_stream)



def test():
    import io

    TEST_CASES = [
        {
            "input": \
"""\
3
kc
kc
kc
""",
            "output": \
"""\
0
""",
        }, 
    ]

    for i, test_case in enumerate(TEST_CASES):
        in_stream = io.StringIO(test_case["input"])
        expected_output = test_case["output"].rstrip()

        out_stream = io.StringIO()
        main(in_stream, out_stream)
        real_output = out_stream.getvalue().rstrip()

        assert real_output == expected_output, \
            f'Test case {i} failed.\nExpected: {expected_output!r}\nGot: {real_output!r}'

    print('Tests passed ðŸ˜Ž')


if __name__ == '__main__':
    test()


```

<RUN_SNIPPET>
```output
Tests passed ðŸ˜Ž

```

Sample input 2:

molzv

lzvmo

Sample output is 2.

Wait, the minimal sum is 2. How?

Let's see. Let's see possible targets.

The first string's rotations include 'lzvmo' at i=2 (move count 2). Does the second string's rotations include 'lzvmo'? The second string's original is 'lzvmo' (i=0), so yes. So for target 'lzvmo':

First string's move count is 2.

Second string's move count is 0.

Sum 2+0=2. Which matches the sample output.

Ah right. So the code would check the target 'lzvmo', which is present in both rotations. The first string's rotation dict has 'lzvmo' mapped to i=2, the second's rotation dict has it mapped to 0. So sum is 2+0=2. That's the minimal sum.

So the code would generate all possible targets from the first string's rotations. The target 'lzvmo' is one of them, and the code would compute the sum correctly.

Thus, the code works for this case.

Another sample: third input, all 'kc', output 0. Because for each string, the rotation is 'kc' (since rotating 0 times) and all can reach it with 0 moves.

Fourth sample: three strings, two 'aa' and one 'ab'. The first two's rotation dictionaries will have 'aa' with 0 moves, but the third string's rotations are 'ab' (i=0), 'ba' (i=1). So when the code checks targets from the first string's rotations (only 'aa'), the third string's dict does not have 'aa', so no valid target. Hence output is -1.

So the code should handle all cases.

Now, considering time and memory constraints.

n is up to 50, each string up to 50 characters. For each string, generating the rotation dict takes O(L^2) time (since for each of L rotations, creating a string of length L, and checking in a dict which is O(1) average case). For L=50, this is 50*50=2500 operations per string. For 50 strings, this is 50*2500=125,000 operations, which is acceptable.

Then, for each possible target in the first string's rotations (up to 50), for each of the 50 strings, checking if the target is in their dict (O(1) per check). So 50 * 50 = 2500 operations. So total steps are manageable, well within time constraints.

Memory-wise, each rotation dict for a string can have up to L entries (if all rotations are unique). For L=50, 50 entries per string, 50 strings: 50 *50=2500 entries. Each entry is a string of length 50, so total memory is about 50*50*50 = 125,000 characters. Which is acceptable for Python's memory.

Thus, the code is efficient.
</think>

```python
n = int(input())
strings = [input().strip() for _ in range(n)]

if n == 1:
    print(0)
    exit()

rot_dicts = []
for s in strings:
    d = {}
    l = len(s)
    for i in range(l):
        rotated = s[i:] + s[:i]
        if rotated not in d:
            d[rotated] = i
    rot_dicts.append(d)

min_total = None
first_dict = rot_dicts[0]
for target, moves in first_dict.items():
    total = moves
    valid = True
    for i in range(1, n):
        current_dict = rot_dicts[i]
        if target not in current_dict:
            valid = False
            break
        total += current_dict[target]
    if valid:
        if min_total is None or total < min_total:
            min_total = total

print(min_total if min_total is not None else -1)
```
