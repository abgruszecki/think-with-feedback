```python
def main():
    import sys
    input = sys.stdin.read
    data = input().splitlines()
    
    t = int(data[0])  # Number of test cases
    results = []
    
    for i in range(1, t + 1):
        a, b = map(int, data[i].split())
        
        total_hours = a  # Start with the initial candles
        current_stubs = a  # Initial stubs from the burned candles
        
        while current_stubs >= b:
            new_candles = current_stubs // b  # Number of new candles we can make
            total_hours += new_candles  # Add the new candles' burning time
            current_stubs = (current_stubs % b) + new_candles  # Update stubs
        
        results.append(total_hours)
    
    print("\n".join(map(str, results)))

if __name__ == "__main__":
    main()
``` 

### Explanation of the Code:
1. **Input Handling**: The code reads all input at once for efficiency, especially since there can be up to 10,000 test cases.
2. **Loop Through Test Cases**: For each test case, it extracts the values of `a` (initial candles) and `b` (candles needed to make a new one).
3. **Calculate Total Hours**: It initializes `total_hours` with the number of initial candles and keeps track of `current_stubs`.
4. **While Loop**: As long as there are enough stubs to create new candles, it calculates how many new candles can be made, adds their burning time to the total, and updates the stubs.
5. **Output**: Finally, it prints the results for all test cases in one go, which is more efficient than printing line by line.

### Complexity:
- **Time Complexity**: Each test case runs in O(log(a)) due to the while loop, as the number of stubs decreases significantly with each iteration.
- **Space Complexity**: O(1) for variables and O(t) for storing results, where `t` is the number of test cases. 

This approach efficiently handles the maximum constraints and ensures that the calculations are performed within the time limits.
