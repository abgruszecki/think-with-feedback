<think>


Test case 1: a=4, b=2.

stubs=4.

Loop:

new=4//2=2 → total=4+2=6. stubs=0+2=2.

Loop again: new=2//2=1 → total=7. stubs=0+1=1. Exit. Correct.

Test case 2: a=6, b=3.

stubs=6 → new=2. total=8. stubs=0+2=2. 2<3 → exit. Correct.

Another test case: a=5, b=5. Then initial 5. stubs=5. new=1. total=6. stubs=0+1=1. Exit. So total 6.

Another test case: a=7, b=3. Let's see:

Initial total=7, stubs=7.

First iteration: 7//3=2. total=9. stubs=7%3=1 +2=3.

Second iteration: 3//3=1. total=10. stubs=0 +1=1. Exit. So total 10.

Which is 7 +2 +1=10. Correct.

So the code works.

Now, in Python, the code is straightforward. Read a and b, compute as per the loop.

So the code would be:

a, b = map(int, input().split())

total = a

stubs = a

while stubs >= b:

    new = stubs // b

    total += new

    stubs = stubs % b + new

print(total)

Yes. That's the code. It's O(log_b a) time, which is acceptable for the constraints (a up to 1e3, which is very small). So even for a=1e3 and b=2, the loop runs about 10 times (since each time the stubs are halved, but added with the remainder). So no problem with time.

So this should be the correct solution.

</think>
```python
a, b = map(int, input().split())
total = a
stubs = a
while stubs >= b:
    new = stubs // b
    total += new
    stubs = stubs % b + new
print(total)
```
