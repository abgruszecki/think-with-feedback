<think>
Wait, maybe the process is:

Initially, total hours is a. The stubs are a.

Then, while stubs >= b:

    new_candles = stubs // b

    total += new_candles

    stubs = (stubs % b) + new_candles

So this loop continues until stubs < b.

Yes, that's the correct approach.

So for the first example:

a=4, b=2.

stubs =4.

Loop:

new_candles=4//2=2. total +=2 (now 4+2=6). stubs =4%2=0 +2=2.

Next iteration: stubs=2 >=2.

new_candles=1. total +=1 (7). stubs=0 +1=1. Now 1 <2. Exit. Total is 7.

Yes.

Second example: a=6, b=3.

stubs=6.

new_candles=6//3=2. total +=2 (6+2=8). stubs=0 +2=2. 2 <3. Exit. So total is 8.

So the algorithm is:

total = a

stubs = a

while stubs >= b:

    new = stubs // b

    total += new

    stubs = (stubs % b) + new

So this loop will handle all the possible conversions.

Now, the code in Python would be straightforward.

Read a and b.

Initialize total = a, stubs =a.

Loop while stubs >=b:

    new = stubs //b

    total += new

    stubs = (stubs %b) + new

Then print total.

Yes. That's the code.

Testing the first sample:

a=4, b=2.

stubs=4.

Loop:

new=2. total=4+2=6. stubs=0+2=2.

Loop again:

new=1. total=6+1=7. stubs=0+1=1. Exit.

Output 7.

Second sample:

a=6, b=3.

stubs=6.

new=2. total=8. stubs=0+2=2. 2<3. Exit. Output 8.

Another test case: let's say a=5, b=2.

Initial total 5. stubs=5.

First iteration: 5//2=2. total 7. stubs=5%2=1 +2=3.

Next iteration: 3//2=1. total 8. stubs=1+1=2.

Next: 2//2=1. total 9. stubs=0+1=1. Exit. So total is 5+2+1+1=9? Wait, no. Let's see:

Wait, initial a=5. So first total is 5. stubs=5.

First loop: new=2. total becomes 5+2=7. stubs=5%2=1 +2=3.

Second loop: new=3//2=1. total 8. stubs=3%2=1 +1=2.

Third loop: new=1. total 9. stubs=0 +1=1. Exit. So total is 9.

Yes. So for a=5, b=2, output is 9.

So the code works.

So the code is straightforward. Now, in Python, the code would be:

a, b = map(int, input().split())

total = a

stubs = a

while stubs >= b:

    new = stubs // b

    total += new

    stubs = stubs % b + new

print(total)

Yes. That's the code. It's O(log_b a) time, which is acceptable for the constraints (a up to 1e3, so even for 1e3, log_2(1e3) is about 10 steps. So even for 1e4 test cases, it's manageable.

So the code is correct.

</think>
```python
a, b = map(int, input().split())
total = a
stubs = a
while stubs >= b:
    new = stubs // b
    total += new
    stubs = stubs % b + new
print(total)
```
